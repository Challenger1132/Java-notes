本地通过广播进行通信，在本地通信通过Mac地址
无法通过设备的物理地址来区分不同的设备在哪个网络中，因此给每个设备赋予一个逻辑地址(IP地址)
路由器是在不同的网络中进行通信的，连接的不同网络(不同的广播域)一个设备发现目的主机不在本地网络，那么会通过路由器进行转发
	路由器在内部维护一张路由表
IP地址分为两段 网络地址.主机地址   网络地址标识主机在那个网络中，主机地址标识本地网络中的不同主机
子网掩码：用来取一个IP地址的网络地址，与网络地址对应全为1，与主机地址对应全为0   255.255.0.0  
通过子网掩码判两个主机是否在同一个网络中，本地主机IP和网关一定在同一个网络中
在通信的过程中，MAC地址用来标记本地网络的通信的，通信过程中(根据本地网络不同)一直发生变化，
IP地址用来进行主机到主机之间的通信(用来表示源主机和目的主机)，从源主机到目的主机之间通信过程中一直保持不变
当数据到达接收端，通过相应的端口发送给对应的进程，一些著名的服务，为其分配了固定的端口号
IP地址与端口号称为socket

1、C语言的传参规则是Call by Value
返回语句写成return x;，返回的也是变量x的值，而非变量x本身，因为变量x马上就要被释放了
函数返回一个值相当于定义一个和函数返回值类型相同的临时变量并用return后面的表达式来初始化
2、递归：factorial(3)的参数n和factorial(2)的参数n各自有各自的空间，虽然它们的变量名相同都是n
3、每个函数调用的参数和局部变量的存储空间称为一个栈帧(Stack Frame)系统为每个程序的运行预留了栈空间，
函数调用时就在这个栈空间里分配栈帧，函数返回时就释放栈帧
深刻理解函数的调用以及最后的返回，是用栈来实现的，函数被调用时就会开辟栈空间(入栈)，
在栈空间里为参数和局部变量分配栈帧，当这个函数去调用另一个函数的时候，另一个空间会被压入栈，
最先入栈的最先返回，特别是函数的递归，每进行一次递归，就会将一个栈空间入栈
4、	enum coordinate_type { RECTANGULAR, POLAR };
	struct complex_struct {
	enum coordinate_type t;
	double a, b;
	};
5、结构体也是一种递归定义：结构体由数据类型定义，因为结构体的成员具有数据类型，而数据
类型由结构体定义，因为结构体本身也是一种数据类型
6、预处理：在这里预处理器做了两件事情，一是把头文件stdio.h和stdlib.h在代码中展开，二是
把#define定义的标识符N替换成它的定义20
	#include <stdio.h>
	#define N 20
7、c语言中函数不能直接返回一个数组，但是可以用其他方式实现类似功能，不过需要注意：
该数组不能是返回函数的局部变量数组，因为局部变量数组在退出函数后会被释放
可以是全局变量，静态局部变量，动态分配内存，以及从函数参数传过来的数组地址
8、栈和深度优先搜索：每次取一个相邻的点走下去，一直走到无路可走了再退回来，取另一个相邻的点再走下去
探索问题的解时走进了死胡同，则需要退回来从另一条路继续探索，这种思想称为回溯（Backtrack）
队列和广度优先搜索：使得先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问
访问一个顶点的各个邻接点，接着按序访问邻接点的各个邻接点，在队列中，拿起一个顶点，把该顶点的相邻节点依次放进去
广度优先搜索的缺点：在树的层次较深且子节点数较多的情况下，消耗内存十分严重，(需要很大的队列空间)
广度优先搜索适用于节点的子节点数量不多，并且树的层次不会太深的情况
深度优先就每次搜的过程，每一层只需维护一个节点，深度优先的方法是一条路走到黑，那显然无法知道这条路是不是最短的，所以你还得继续走别的路去判断是否是最短路，深度优先搜索的缺点：难以寻找最优解，仅仅只能寻找有解。其优点就是内存消耗小，克服了刚刚说的广度优先搜索的缺点
广度优先搜索的话，搜索到终点时，该路径一定是最短的
给出一个顶点，将与该顶点的相邻点的点全部压入栈，从栈中弹出一个点，再将与该点相邻的点全部压入栈  深入
给出一个顶点，将与该顶点的相邻点的点全部入队列，从队列取出一个点，再将与该点相邻的点全部入队列  辐射
9、临界矩阵表示无向图：两个数组来表示图 一个一维数组存储图中顶点信息 一个二维数组(邻接矩阵)存储边的信息
对于n个顶点，邻接矩阵是n*n的方阵，无向图是关于主对角线对称的，有向图不是对称的(主对角线元素全为0)
每条边上都带有权的图叫做网，这些权值就需要保存下来因此邻接矩阵中元素是相应的权值或者∞ (主对角线元素全为0)
无向图顶点的度，即为第i行的所有元素和(无所谓行和列)
有向图顶点的出度，即为第i行的所有元素和；入度为第i列的所有元素和
对于稀疏图邻接矩阵的存储会造成巨大的空间浪费

邻接表，每个顶点vi的所有邻接点构成一个线性表，就是哈希或者哈希数组
头结点 边链表节点
n个顶点，e条边的无向图而言，需要n个表头结点和2e个边链表结点
n个顶点，e条边的有向图而言，需要n个表头结点和e个边链表结点
无向图：出度就是某个头结点对应边链表结点的个数，入度等于出度
有向图：出度等于某个头结点对应边链表结点的个数，入度计算比较复杂，需要遍历整个邻接表

桶
查表大法
