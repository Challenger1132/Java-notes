阅读关于CSI相关论文
对用USRP获取CSI数据进行处理
用USRP实现RSSI的计算
关注CSI tool
专业术语看不懂就查资料，英语不好就多看，密密麻麻全是中文得翻译
每天坚持看两篇与自己所做领域相关的英语文章，一直坚持到最后，。。。。
/*
关于MATLAB：
有符号整数型：int8，int16，int32，int64
无符号整数型：uint8，uint16，uint32，uint64
单精度浮点型：single
双精度浮点型：double
logical: true false
字符串型：char
单元数组型：cell
结构体型：struct
函数句柄型：function_handle

matlab中小数取整的函数大约有四个：floor、ceil、round、fix
若 A = [-2.0, -1.9, -1.55, -1.45, -1.1, 1.0, 1.1, 1.45, 1.55,  1.9, 2.0];
floor:朝负无穷方向靠近最近的整数；
floor(A)
ans =
    -2    -2    -2    -2    -2     1     1     1     1     1     2
ceil:朝正无穷方向靠近最近的整数；
ceil(A)
ans =
    -2    -1    -1    -1    -1     1     2     2     2     2     2
round:取最近的整数（相当于四舍五入）
round(A)
ans =
    -2    -2    -2    -1    -1     1     1     1     2     2     2
fix:取离0最近的整数
 fix(A)
ans =
    -2    -1    -1    -1    -1     1     1     1     1     1     2

length计算数组的长度，矩阵的行和列中最大值
size 返回行和列

row 是横向的， 排的意思
column 是纵向的， 列的意思

numel
功能：计算一个数组所有的元素数或指定下标的元素总数

x是二维矩阵：
x(1, :) 提取矩阵的第一行
x(:, 1) 提取矩阵的第一列
x(1:3, :) 提取矩阵的前三行
x(:, 1:3) 提取矩阵的前三列
x([1,4,6], :) 提取矩阵的第1 4 6行
x(:, [1,4,6]) 提取矩阵的第1 4 6列
x(3,4) 取出矩阵第三行第四列处的元素
x([2,4], [4,5]) 画方格，提取矩阵第2,4行与第4,5列出的元素

>> x = 1:10
x =
     1     2     3     4     5     6     7     8     9    10
>> y = 4:5
y =
     4     5
>> [m,n] = meshgrid(x,y)
m =
     1     2     3     4     5     6     7     8     9    10
     1     2     3     4     5     6     7     8     9    10
n =
     4     4     4     4     4     4     4     4     4     4
     5     5     5     5     5     5     5     5     5     5
1、meshgrid 函数的作用是取格点，x的坐标是1到10，y的坐标是4到5，在x和y规定的区域划格点
反映在m和n中，注意坐标元素对应,注意矩阵是先行再列，正好和常规坐标轴y轴和x轴相对应
而meshgrid第一个参数是x,第二个参数是y，这里要注意
2、meshgrid函数第一个参数是x轴坐标，和m对应，反映在图形上是从左向右的轴
3、meshgrid函数第二个参数是y轴坐标，和n对应，反映在图形上是从下向上的轴
4、MATLAB 绘图从左向右呈现的是x轴，从下到上呈现的y轴，想要哪个数据作为x轴
	就放在meshgrid的x的位置，作为y轴数据就放在参数y的位置
5、meshgrid返回矩阵的维度是一样的
6、交换mesh(xx, yy, zz); 中xx和yy的位置，就交换了x轴和y轴数据，zz数据不用发生变化
一下三种方式等效：
	%% MUSIC_AOA_TOF可视化
	hMUSIC = figure('Name', 'MUSIC_AOA_TOF1', 'NumberTitle', 'off');
	[meshAoA,meshToF] = meshgrid(aoa,tof);
	mesh(meshAoA, meshToF*1e9, Pmusic.');
	xlabel('X Angle of Arrival in degrees[deg]');
	ylabel('Y Time of Flight[ns]')
	zlabel('Z Spectrum Peaks[dB]')

	hMUSIC = figure('Name', 'MUSIC_AOA_TOF2', 'NumberTitle', 'off');
	[meshAoA, meshToF] = meshgrid(aoa, tof);
	mesh(meshToF*1e9, meshAoA, Pmusic.');
	ylabel('Y Angle of Arrival in degrees[deg]');
	xlabel('X Time of Flight[ns]')
	zlabel('Z Spectrum Peaks[dB]')

	hMUSIC = figure('Name', 'MUSIC_AOA_TOF3', 'NumberTitle', 'off');
	[meshToF, meshAoA] = meshgrid(tof, aoa);
	mesh(meshToF*1e9, meshAoA, Pmusic);
	ylabel('Y Angle of Arrival in degrees[deg]');
	xlabel('X Time of Flight[ns]')
	zlabel('Z Spectrum Peaks[dB]')

MATLAB中的reshape函数对矩阵进行变形是按照列进行的，无论源数据是一个行向量还是列向量
都是源数据先满足第一列，而后满足第二列进行，在必要的时候需要进行转置
gnuradio写数据是实数虚数交替进行，在进行读取数据的时候 t = fread (f, [2, count], 'float');
刚好转换成第一行是实数，第二行全是虚数的形式，
源数据：
I
Q
I
Q
I
Q
...
I I I I I
Q Q Q Q Q ...
t = fread (f, [2, count], 'float');实际对源数据进行了reshape(ori, 2,count)

MATLAB cftool是曲线拟合工具箱
	从工作空间选择数据，设置参数进行拟合，残差图、排除异常值(exclude outliers)等等
	将你和的结果导入到工作空间：在底部的table of fits 中选中行右键，save ... to Workspace
	选择file -- print to Figure 设置图像的显示参数等等、当前界面下生成图像的code
	或者将拟合过程封装成函数，方便调用 -- file -- generate code 

	结果中的R-square = (sst - sse) / sst
	R-square是“确定系数”是通过数据的变化来表征一个拟合的好坏，正常取值范围为[0 1]越接近1，表明方程的变量对y的解释能力越强，这个模型对数据拟合的也较好

数理统计中，残差是指实际观察值与估计值（拟合值）之间的差
MATLAB中的所有元素都是按列进行排列的 A(:)是将所有元素按列排序，矩阵转化为向量
std是标准差，var是方差，方差和标准差都有有偏和无偏估计
var(data)和var(data,0)效果一样，是无偏方差，除以的是N - 1
var(data,1)表示有偏方差，除以的是 N
var第三个参数表示对于矩阵是按行求，还是案列求，1,2分别表示按列和按行进行求
同理std是标准差的函数，与方差参数类似

方差的公式是：实际值与期望值之差的平方和再除以N
这个公式是针对度量总体(population)的，是全体数据，
而matlab的函数var和std认为操作数是度量总体的一个样本(sample)
所以使用的公式为实际值与期望值之差的平方和再除以 N-1
一种是度量总体，一种是度量中体的一个样本

自己求方差和标准差和MATLAB自带函数不一致实际是除以N以及除以N-1的问题
关于N和N-1的问题
因为样本我们认为是i.i.d的，N个样本求均值时，是除以N，而求方差时除以N-1，是因为这个时候只有N-1个样本是独立的
（N*mean=N1+N2+.....）,因为求方差的时候我们引进了mean,mean和每个样本有关系

当X是一个向量 var(X) 和cov(X) 是一样的，计算X的方差
cov(x, y) 计算x和y的协方差矩阵，协方差矩阵有4个元素 c(x,x) c(x,y)
													c(y,x) c(y,y)
						当x和y是元素数目相同的矩阵的时候，计算cov(x(:), y(:))
						
	>> x = rand(4,4);
	>> y = rand(1,16);
	>> cov(x,y)
	ans =

		0.0819    0.0569
		0.0569    0.1163
	也就是x和y维度虽然不一样，但是元素数目一样，可以进行cov计算，其实是cov(x(:), y(:)) 结果是4个元素
	就是两个向量或者矩阵进行cov 都会先将其转换为列向量(整个矩阵转换为列向量x(:)) 然后计算协方差矩阵
	(结果是4个元素)	
但是一个矩阵进行cov,计算矩阵列之间的协方差矩阵，结果协方差矩阵维度是 size(x,2) * size(x,2) 大小
协方差矩阵计算的是不同维度之间的协方差，而不是不同样本之间的

1、方差：变量偏离平均值的度量，反映的是数据分布的离散程度，元素偏离平均值的平方求和，取均值
2、协方差：反映两个随机变量的相关性(正相关，负相关，不相关)，是变量之间的二阶统计特性
3、相关系数：协方差除以两个随机变量标准差的乘积(协方差和相关系数是一样的，只是相关系数进行了归一化)
4、协方差矩阵：由协方差扩展成的矩阵，计算的是数据不同维度(列)之间的协方差，而不是不同样本之间的，
	作为刻画数据不同分量(列)之间相关性
5、A = cov(X); A(i, j) 表示X的第i列和第j列相关性的刻画
6、独立 ---> 不相关 <---> 相关系数(协方差为0)
7、有些博客上面写“协方差越大，相关性越强，协方差越小，相关性越弱”是不正确的
相关性的越强应看相关系数大小(进行了归一化)，因为可以认为构造出协方差值很大向量
>> x = [1 2 100 500];
>> y = [-4 -999 0 400];
>> corrcoef(x, y)

ans =

    1.0000    0.6801
    0.6801    1.0000
>> cov(x, y)
ans =
   1.0e+05 *
    0.5637    0.9630
    0.9630    3.5570
>> 协方差的值很大但是相关性很弱


x =
     1     2     3     4
>> y
y =
     2     4     6     8
>> corrcoef(x, y)
ans =
     1     1
     1     1
>> cov(x, y)
ans =
    1.6667    3.3333
    3.3333    6.6667
>> 协方差的值很小但是相关性很强

以上是数学意义上的协方差，但是DOA中，E{XX’} 也称为协方差矩阵，当然两者都是对称阵


计算相关系数矩阵，用法和cov类似 co = corrcoef(x)
计算x的夹角余弦：
	将矩阵转化为单位向量  nx = normc(x)
						cthta = nx' * nx

距离矩阵 一个矩阵，每一行视为一个样本，计算行与行之间的距离的矩阵
	距离矩阵主对角线元素全为0
	系数矩阵主对角线元素全为1
	协方差矩阵主对角线元素全为方差

要明确矩阵的行和列代表的意义 矩阵的每行是一个样本，每列是一个维度
每一行表示一个样品，每一列表示一个指标

MATLAB聚类分析：
M个元素，两两形成关系对，共有M*(M-1) / 2 个关系对

类间距离 按照某种规则计算的类与类之间的距离，例如 类元素之间的最小距离定义为类之间的距离
最长距离，平均距离，重心距离，离差平方和距离

类 包含了很多样本
类之间的距离   样本之间的距离
n个样品的p元观测数据组成一个n*p的矩阵，每一行表示一个样品，每一列表示一个指标
聚类分析的思想就是在样品之间定义距离，在指标之间定义相似系数
每个样品可以看成p元空间的一个点
	
x.'  求矩阵的非共轭转置
x' 	求矩阵的共轭转置
x =
   1.0000 + 2.0000i   3.0000 + 4.0000i   4.0000 + 4.0000i
   
>> x.'
ans =
   1.0000 + 2.0000i
   3.0000 + 4.0000i
   4.0000 + 4.0000i

>> x'
ans =
   1.0000 - 2.0000i
   3.0000 - 4.0000i
   4.0000 - 4.0000i

>> conj(x)   x的共轭
ans =
   1.0000 - 2.0000i   3.0000 - 4.0000i   4.0000 - 4.0000i
   
>> transpose(x)   x的非共轭转置
ans =
   1.0000 + 2.0000i
   3.0000 + 4.0000i
   4.0000 + 4.0000i 

首先,置信水平和置信度应该是一样的,就是变量落在置信区间的可能性,“置信水平”就是相信变量在
设定的置信区间的程度,是个0~1的数,用1-α表示.
置信区间,就是变量的一个范围,变量落在这个范围的可能性是就是1-α.
显著性水平就是变量落在置信区间以外的可能性,“显著”就是与设想的置信区间不一样,用α表示.
显然,显著性水平与置信水平的和为1.
显著性水平为0.05时,α=0.05,1-α=0.95
如果置信区间为（-1,1）,即代表变量x在（-1,1）之间的可能性为0.95.
0.05和0.01是比较常用的,但换个数也是可以的,计算方法还是不变.
总之,置信度越高,显著性水平越低,代表假设的可靠性越高,越好.
   
关于FFT与IFFT：
% 实现对时域信号进行离散傅里叶变换
function Xk = myfft(xn)
	N = length(xn);
	K = N;
	n = 0:N-1;
	k = 0:N-1;
	Wn = exp(-j*2*pi/N);
	base = n'*k; % N*N
	Wnnk = Wn.^base;
	Xk = xn*Wnnk';
end
% 实现对时域信号进行逆离散傅里叶变换
function xn = myifft(Xk)
	N = length(Xk);
	K = N;
	n = 0:N-1;
	k = 0:N-1;
	Wn = exp(-j*2*pi/N);
	base = n'*k; % N*N
	Wnnk = Wn.^(-base);
	xn = Xk*Wnnk' / N;
end

% 自定义的函数与自带函数不一样，复数中间的符号相反，但是模值相等,不论是fft 还是iffft
傅里叶变换对行进行和对列向量进行得到结果对称，这一点要注意

“where n is the size of X in the first nonsingleton dimension”
X的第一个非单一元素维度
若X为一个m1 × m2 × m3 ×...× mk的矩阵   高维矩阵**
如果m1大于1，那么第一个非单一元素维度就是m1
如果m1为1，而m2大于1，那么那么第一个非单一元素维度就是2
如果m1、m2、...、mp都为1，而mp+1大于1，那么那么第一个非单一元素维度就是mp+1
可用函数squeeze()去除矩阵的一维维度
N点长度不够补零，大于截断
Y = fft(X,n) returns the n-point DFT. fft(X) is equivalent to fft(X, n) where n is
the size of X in the first nonsingleton dimension.If the length of X is less than n, 
X is padded with trailing zeros to length n. If the length of X is greater than n,
the sequence X is truncated. When X is a matrix, the length of the columns are 
adjusted in the same manner.(矩阵的每一列都按相同的方式进行调整，即每一列都进行补0或者截断)
MATLAB是“按列进行”的 **

对于二维平面上的数据，我们可以计算出在x方向上的方差δx以及y方向上的方差δy，然而
数据的水平传播和垂直传播不能解释明显的对角线关系，平均而言，如果一个数据点的x值增加，则y值也将增加
这产生了正相关。这种相关性可以通过扩展方差概念到所谓的数据“协方差”捕捉到
协方差是数据相关性的度量，且是二维的，即一个维度和另一个维度之间的相关性的刻画，不是三个维度之间的
如果x与y是正相关的，那么y和x也是正相关的，协方差矩阵是对称阵，其对角线上是方差，非对角线上是协方差
二维正态分布数据由它的均值和2x2协方差矩阵就可以完全解释。同样，一个3x3协方差矩阵用于捕捉三维数据的传播，
一个NxN协方差矩阵捕获N维数据的传播。只是高维数据不具有形象化

A cell array is a collection of containers called cells in which you can store 
different types of data
精华之处就是在可以存储不同类型的数据，可以是Matlab的类型或者自定义的类型

pdist函数：计算矩阵X各行之间的距离，注意第二个参数使求解按照某种算法进行，如欧式距离、名氏距离等等
是矩阵两行之间的距离
d = pdist(X); 得到的是一个矩阵各行之间的一个行向量，还可以添加一个参数，按照某种算法求两个向量之间的距离
dm = squareform(d); 将距离向量变换为距离矩阵的形式，距离矩阵是一个实对称矩阵
dd = tril(dm); 距离矩阵的形式变换为上三角的形式
lk = linkage(d); linkage函数的到系统聚类树，要用到pdist的结果，注意这里也有一个参数，计算的是类间距离
dg = dendrogram(lk, d); 得到谱系聚类图,如果d小于30可以省略
cc = cluster(lk, k); linkage的结果传给cluster函数进行聚类，k是聚类数目
ch = cophenent(lk, d); 利用pdist函数生成的d和linkage函数生成的lk计算cophenet相关系数
选择样本之间(矩阵的某一行)不同的距离算法，不同的类间距离，如何评估聚类的效果呢？
用复合相关系数 越接近1 聚类效果越理想

对linkage函数返回结果的分析：
对于原始矩阵X，共M行(M个样本)，用pdist函数计算，返回一个 M*(M-1)/2的行向量
(每一个元素是各行之间的距离， M*(M-1)/2代表各行之间的组合数)
linkage函数返回结果lk则是(M-1)*3的矩阵,lk矩阵的前两列是索引下标列，
代表矩阵X中哪两行应该聚类到一起，也就是表示哪两个序号的样本可以聚为同一类，第三列为这两个样本之间的距离
除了M个样本以外，对于每次新产生的类，依次用M+1、M+2、…来标识

lk = linkage(d)
lk =
     3.0000     4.0000     0.2228
     2.0000     5.0000     0.5401
     1.0000     7.0000     1.0267
     6.0000     9.0000     1.0581
     8.0000    10.0000     1.3717
上例中表示在产生聚类树的计算过程中，第3和第4点先聚成一类，他们之间的距离是0.2228，
以此类推。要注意的是，为了标记每一个节点，需要给新产生的聚类也安排一个标识，MATLAB中
会将新产生的聚类依次用M+1,M+2,....依次来标识。比如第3和第4点聚成的类以后就用7来标识，
第2和第5点聚成的类用8来标识，依次类推。通过linkage函数计算之后，实际上二叉树式的聚类已经完成了
lk这个数据数组不太好看，可以用dendrogram(lk)来可视化聚类树
X M
pdist M*(M-1)/2
linkage (M-1) * 3

flip翻转矩阵
fliplr(x) 将矩阵左右反转，若x是一个列向量，则x不变，lr代表left、right
flipud(x) 将矩阵上下反转，若x是一个行向量，则x不变，ud代表up、down

MATLAB矩阵都是按列进行的 ****
1、reshape
2、进行fread fwrite进行文件读写，第二个参数[M N] 进行M*N的矩阵操作
3、var、std、cov、corrcoef、按列进行，如果矩阵是N列，得到N*N的矩阵(包含向量得到一个数)
	如果是元素数目相等的两个矩阵或者向量，得到2*2的矩阵
4、db函数 plot函数 按列进行
5、fft ifft n = length(x), fft(X)与fft(X,n)等价，进行n点DFT
	矩阵的每一列都按相同的方式进行调整，即每一列都进行补0或者截断
5、pdist 求M*N矩阵的距离矩阵，按行进行，得到M*(M-1)/2的行向量

sort 非常重要，特别是返回的index矩阵，排序完毕的矩阵SX经过index可以进行逆运算
[Y,I] = sort(X,DIM,MODE)
sort函数默认Mode为'ascend'为升序，sort(X,'descend')为降序排列
若欲保留排列前的索引，则可用[sX,index] = sort(X) ，排序后，sX是排序好的向量
index是 向量sX中对X 的索引，索引使排列逆运算成为可能
事实上，这里X≡sX(index), [X恒等于sX(index)]，这个结论确实很奇妙，而且很有用
就是对矩阵X按行按列进行排序后，返回排好序的矩阵SX以及SX对X的索引矩阵，
SX对索引矩阵index作用返回原来未排序的矩阵X

如何交换矩阵的行和列？
如矩阵x有四列 x = x(:, [4 2 3 1]); x矩阵的第一列和第四列进行交换，对行亦是如此

findpeaks函数的使用：
[pkttof,lcttof]  = findpeaks(PmusicEnvelope_ToF,...
		'SortStr','descend','NPeaks',num_computed_paths);
返回数据的局部最大值，以及最大值出现的下标index，峰值可以按照升序、降序进行排列，
相应的index也会进行相应的调整，还可以设置其他的属性值

关于AOA以及TOF联合估计伪谱峰值搜索的总结：
1、每个角度值theta以及时间值tau都可以确定一个导向矢量，alpha(θ)(与具体的信号无关，
只与aoa以及tof的值有关)，和噪声空间运算可以得到Pmusic矩阵的一个元素Pmusic(i,j)
2、对Pmusic矩阵按行找最大值，找到的是aoa的包络，按列找最大值，找到的是tof的包络
3、对包络进行findpeaks，返回相应包络的峰值以及出现峰值的index
	[pkttof,lcttof]  = findpeaks(PmusicEnvelope_ToF,...
		'SortStr','descend','NPeaks',num_computed_paths);
注意这里面index仅仅是峰值的下标，并不是真正的峰值对应的aoa或者tof，
aoa(index), tof(index)，才是真正的aoa峰值对应aoa，以及tof峰值对应的tof值
4、Pmusic是一个矩阵，如何找矩阵中的某个元素，还是按照index进行查找，
并不是按照真正的角度值或者时间值进行查找 Pmusic(aoa_index, tof_index)
x_aoa = aoa(aoa_index)  y_tof = tof(tof_index)
5、但是对于plot3函数，在Pmusic 3-D图像上标记一个点，则要使用真正的aoa值，以及tof值
plot3(currentAxis, x_aoa, y_tof, z_dB, 'o', 'MarkerSize', 12);
对于矩阵和矩阵代表的图像，都要找同一个点，矩阵中使用下标，绘图中使用下标对应的真实的值
6、对3-D图像某点进行标记，
h = figure('Name', 'figure_name', 'NumberTitle', 'off');
currentAxis = get(h, 'CurrentAxes');
plot3(currentAxis, x_aoa, y_tof, z_dB, 'o', 'MarkerSize', 12);
注意plot3函数的第一个参数是axis，而不是figure

rand以及randn函数
rand产生均匀分布的伪随机数 (0 ~ 1)
randn标准正太分布的伪随机数 均值为0 方差是1

repmat全称是Replicate Matrix ，意思是复制和平铺矩阵，是MATLAB里面的一个函数
repmat函数可以这样来理解，repmat(A, m, n);产生一个m行n列的一个矩阵，
该矩阵的每个元素都用A来代替
x =
     1     2
     3     4
>> repmat(x, 2, 3)
ans =
     1     2     1     2     1     2
     3     4     3     4     3     4
     1     2     1     2     1     2
     3     4     3     4     3     4

>> x = 'matlab ';
>> repmat(x, 2, 3)
ans =
matlab matlab matlab 
matlab matlab matlab	 

save('CSI.mat','CSI', 'A');	% 将矩阵CSI 以及A都保存到CSI.mat中	 
load('CSI.mat'); 将数据加载到workspace中	 


>> x = [2 3 4 1];
>> y = diag(x)
y =
     2     0     0     0
     0     3     0     0
     0     0     4     0
     0     0     0     1
就是将x的元素作为y的主对角线元素，并将对角阵返回

关于CSI数据的处理
csi_trace = read_bf_file('cai_5.dat');  % 返回的是一个N*1的cell，其中每个cell是一个struct
csi_entry = csi_trace{index}; % 每一个cell是一个struct，包含了各种信息
csi = get_scaled_csi(csi_entry);  % 得到struct里面的CSI数据是一个Ntx * Nrx * 30的 complex double矩阵
	csi也就是csi_entry.csi
	csi = csi(1, :, :); 取出发端一天线的数据 1*3*30 	squeeze(csi).' 	30*3
plot(db(abs(squeeze(csi).')))

关于矩阵特征值和奇异值：
A’A的特征值就是AA’的特征值，特征向量也有关系
B = A’A
C = AA’
B的特征向量是x 	x = A'y
C的特征向量是y	y = A x
若A不是方阵，当A’A维度很大的时候，不利于计算，可以转换为AA’，
且两者特征值一样，并且特征向量可以相互转换

我个人的理解,奇异值是特征值的一种推广，因为只有方阵才可能具有特征值,对于实际遇到的一些问题
往往遇上长方阵,长方阵根本没有特征值，因而就有必要对特征值做推广,这就是奇异值
再看什么是奇异值，对于任意矩阵A(甚至是非方的),A(T)A(这个时候就变成方阵了,可以算特征值了)
的特征值就称为A的奇异值,奇异值有个特性,就是A(T)A和AA(T)特征值相同,特征向量可以相互转换

再看奇异值为什么重要.我们知道,对于一个方阵来说,特征分解后,从特征值和特征向量我们就可以知道矩阵的大量性质.
对于非方阵来说,我们也希望得到一个这样信息量巨大的分解,这就是奇异值分解(SVD)

向量在坐标系C1中坐标为(a, b),向量不变，坐标系变换为C2，在C2中的坐标为(b', b')
将坐标系C1变换为坐标系C2的变换矩阵记为U，那么向量在坐标系C2中表示为U(a, b)

矩阵是一种变换，矩阵乘以向量，是对向量的一种变换
正交阵乘以向量，就是对向量进行正交变换，所以U对x的变换是正交变换，它将x用新的坐标系来表示
Ux就是向量x经过正交变换后，在当前坐标系下的坐标

正交：两个向量的内积如果是零，那么就说这两个向量是正交的
	内积：点积，数量级，就是两个向量对应元素乘积求和
正交矩阵(不叫单位正交矩阵)：正交矩阵的行(列)都是单位向量，且两两正交
																			-----2017.11.06
								

什么是秩？
1、矩阵可以从输入输出的角度进行思考，列的维度是输入维度，行的维度是输出的维度
	因为矩阵相乘AB就是A的行与B的列相匹配
	
2、「秩」是图像经过矩阵变换之后的空间维度，矩阵列空间的维度(矩阵有多少个线性无关的列向量，代表的个数)
矩阵中的最大的不相关的向量的个数，就叫秩，(最大线性无关的向量的个数)
把矩阵看成线性映射那么秩就是象空间的的维数

3、如果矩阵秩远小于样本维数（即矩阵列数），那么这些样本相当于只生活在外围空间中的一个低维子空间，这样就能实施降维操作
4、矩阵A是定义的一种变换，或者说一种映射，矩阵乘以一个矩阵或者向量，就是它作用在矩阵或者向量上的效果Ax
5、A = USV' 对矩阵A进行奇异值分解，矩阵A对向量的作用，可以看做是定义了三种映射，U,V正交阵，正交阵可以看做
只改变了向量的方向，不改变向量的大小
6、Ax = USV'x	有三个变换：第一是V'x，相当于在原始的R^n空间旋转了一下坐标轴，这样只是坐标的变化
不改变向量本身（例如长度不变）；第二是S(V'x)，这相当于沿着各个坐标轴做拉伸，并且如果S的对角线上某些元素为零
那么这些元素所对应的那些坐标轴就相当于直接丢掉了(维度缺失)，最后再U(SV'x)，还是一个坐标轴旋转。
总的来看，Ax就相当于把一个向量x沿着某些特定的方向做不同程度的拉伸（附带上一些不关乎本质的旋转），甚至丢弃
那些没被丢弃的方向个数就是秩了。
7、举个例子，同一个人在不同光照下采得的正脸图像，假设每一张都是192x168的，且采集了50张，
那构成的数据矩阵就为50行192x168列的，但是如果你做SVD分解就会发现，大概只有前10个奇异值比较大
其他的奇异值都接近零，因此实际上可以将接近零的奇异值所对应的那些维度丢掉，只保留前10个奇异值对应的子空间
从而将数据降维到10维的子空间了
8、对相干信号影响MUSIC算法性能的理解
联系到MUSIC算法进行DOA估计问题，要进行矩阵分解，目的在于完美的分出信号子空间和噪声子空间，
且信号子空间的维度等于信号源数目，但是如果信号源是相干的，表现在矩阵分解上就是信号子空间可以被降维
导致信号子空间一部分被划分到噪声子空间，导致两个子空间不完全正交，会大大削弱MUSIC算法的性能

矩阵是满秩的还是不满秩的，矩阵有几个线性无关的特征向量，能够张成多少维的线性空间？
K个线性无关的向量可以张成一个K维线性空间，一个矩阵能够张成多少维的空间，正是由矩阵的秩衡量的
于是把矩阵看成线性映射那么秩就是象空间的的维数
从象空间的角度，矩阵可以看成一个K维空间

空间中的一个向量，可以用空间中的坐标来表示
矩阵是否可以由其特征值和特征向量唯一表示呢？
矩阵有K个线性无关的特征向量，张成K维的线性空间，矩阵的特征值表示对应特征向量方向上的坐标
矩阵A乘以一个向量或者矩阵，就是对该向量或者矩阵在A张成的K维空间中投影，得到的是在该矩阵A张成的K维空间中的坐标  **

矩阵是对空间的一种变换 ****
矩阵描述的就是一种线性变换，可以解读为对空间(空间中的基)的一种特定变换 ****
矩阵乘以一个向量，就是计算线性变换作用在给定向量上的一种途径，矩阵描述了这种线性变换
分别将基坐标变换到矩阵的列向量，在保持网格等距且平行，原点不变的条件下，给定向量随之变化

行列式，对于二维空间，意味着面积，对于三维空间，意味着体积
行列式为0，意味着矩阵不可逆，不满秩，奇异
行列式为0，意味着矩阵将一个给定维度的空间压至更低维度的空间，这时，体积，面积不再成立，因此行列式变为0
行列式不为0，意味着给定维度的空间经过矩阵变换之后维度依旧保持不变，不降维，
比如是二维空间，经过矩阵变换之后，原空间依据是二维空间，没有向更低维的变换

关于求解 Ax = b 的几何解释
	原空间中的向量x，经过矩阵变换之后，变为(空间变换之后的)b
	因此求解方程的含义就是，在原空间中寻找一个向量，使之经过矩阵A的变换之后和向量重合
	Det(A) != 0 那么经过变换之后，空间维度不降低，因此有唯一解
	Det(A) = 0 空间变换之后，被压至更低维度空间，如果压缩之后的空间和b重合，那么这个时候就有无穷解，压缩之后和b不重合，无解
	


一个样本在投影矩阵P的作用下，转换到另一个坐标空间，相当于求得该样本向量在P不同列向量的投影坐标
一个坐标系转换到另一个坐标系，转换矩阵其实不需要标准化(向量单位化，即向量的模为1)
也不需要正交基的矩阵(两两向量正交，即相乘为0)，只要满足上述“线性无关”的要求
只是标准正交阵有诸多的优点，正交阵基向量两两正交，说明两个向量相关性很小，相当于数据在这两个维度上的相关性很小
线性无关不等于不相关，线性无关的向量，一个基向量在另一个基向量上有投影值，但是如果是正交的话，一个向量在另一个向量投影为0

数据就可以从一个度量空间转换到另一个空间，而且可以相互转换A' = P*A, A = P-1*A'，转换矩阵为P
而A和A'是两个空间中的不同表示,只是正交基和标准基会有一些好处

线性无关，例如二维空间中的两个向量，如果不共线，那么这两个向量就是线性无关的
只要有3个向量线性无关，无论向量方向如何，三维空间中的任意一个向量都可以用这3个线性无关的向量来表示
当然3个向量可以是任意方向和大小(只要满足是线性无关的就可以)，如果是两两正交的向量且是单位向量，这是一种特殊的情况

满秩矩阵是可逆的，可逆就可以实现两个坐标系的相互转换

正交就是两个向量相乘为0

任意矩阵都可以进行奇异值分解A = UΣV' 其中U V’是酉矩阵
厄米矩阵可以进行特征值分解A = UΣU'
厄米矩阵特征值都是实的，不同特征值对应的特征向量相互正交
协方差矩阵R是厄米矩阵，因此可以进行特征值分解，如果K个大的特征值不相等，那么K个大的特征值
对应的特征向量相互正交，组成了信号子空间，M-K个小的特征值相等，对应的特征向量组成了噪声子空间
信号子空间和噪声子空间都不是方阵 (M*K、M*(M-K))

信号子空间维度和导向矩阵的维度一样，都是M*K
协方差矩阵是M*M的，进行奇异值分解得到M个奇异值，K个较大的
对应的特征矢量构成信号子空间，信号子空间的列数是K，导向矩阵的列数也是K
等于信号源数

信号源数K
导向矩阵的维度（列数）
信号子空间的维度（列数）
K

峰度和偏态，刻画数据
峰度衡量数据分布的平坦度(flatness)，尾部大的数据分布，其峰度值较大,正态分布的峰度值为3
偏态量度对称性,0说明是最完美的对称性，正态分布的偏态就是0
右偏态为正，表明平均值大于中位数,反之为左偏态，为负
																				-----2017.11.14
线性拟合、线性回归
最小二乘法	“偏差(差值)的平方和最小的原则”
构造目标函数M，对目标函数对参数求偏导来求解拟合函数的各个参数
MATLAB poltfit函数的也是根据最小二乘法的思想进行线性拟合的 (in a least-squares sense)
p = polyfit(x, y, n);
	returns the coefficients for a polynomial p(x) of degree n that is a best fit(in a least-squares sense)
	for the data in y. The coefficients in p are in descending powers, and the length of p is n+1
yfit = polyval(p, x); 返回根据多项式拟合得到的值

save 函数将工作区变量保存到文件中
load 将文件中的变量加载

matlab函数p = randperm(n) 产生包含1到n在内的随机排列permutation
对于一个向量，可以对其index进行randperm，然后对数据的顺序进行重新调整

非奇异  可逆  满秩  行列式不为0

特征向量是变换中留在他所张成空间中的向量
特征向量是一个向量，当在它上面应用线性变换时其方向保持不变
所以描述特征值、特征向量的关系的等式就很好理解了
Av = lambda*v
表示线性变换A对向量v施加作用后，向量v的方向不发生变化，只是长度发生了变化(被压缩或者被拉伸，比例有lambda决定)
对一个线性变换的理解就是，将现在的坐标系中的基(i-hat、j-hat)分别变换到矩阵的列向量所表示的坐标
求解特征值域特征向量Av - lambda*v = 0  (A - lambda*I)*v = 0  Det(A - lambda*I) = 0
直观的表现就是调整A主对角线上的元素，使空间在A的变换下，降至更低的维度

基变换矩阵，取出想用做新坐标系的基的向量坐标，将坐标变为矩阵的列向量，这个矩阵就是基变换矩阵
基变换矩阵，是在两个坐标系之前变换的桥梁
基变换矩阵，是用我们的坐标描述珍妮弗的基向量(基变换矩阵表示用我们的语言描述她的基向量)
从几何角度看，是将我们的坐标系(标准坐标系)转变为珍妮弗的坐标系(取出珍妮弗坐标系的基的向量坐标，组成矩阵的列向量，就是基变换矩阵
	因为珍妮弗坐标系是用我们坐标系下的坐标来表示的)
从数值角度看，是将珍妮弗的坐标下的向量，转换为我们坐标下的向量(珍妮弗坐标下的向量，乘以基变换矩阵，转换为我们坐标系对该向量的描述)
基变换矩阵取逆就是相反的效果
我们坐标系下的向量乘以基变换矩阵的逆矩阵，就是珍妮弗坐标系对该向量的描述
珍妮弗坐标下的向量，乘以基变换矩阵，就转换为我们坐标系下对该向量的描述

如何将珍妮弗坐标系下的向量转旋转90度
基变换矩阵乘以向量，就将新坐标系中的向量转化为当前坐标系中的向量，对变换后的向量施加当前坐标系下的变换
再乘以基变换矩阵的逆矩阵，又变换到了新坐标系下 
珍妮弗坐标下的向量，乘以基变换矩阵，就转换为我们坐标系下对该向量的描述，乘以我们坐标系下的旋转矩阵，再乘以基变换矩阵的逆矩阵
就是珍妮弗坐标系向量旋转90度之后的效果
A’*M*A就是一种转移变换，M是我们常见的变换，A'和A代表转移，是视觉上的转换
A’*M*A整体是从珍妮弗的角度观察的转换(从我们角度观察的变换是M)


协方差矩阵、系数矩阵、距离矩阵
非凸函数、
K-means聚类算法
聚类分析 
FFT IFFT
SVM

matlab更改文本编码格式为 UTF-8
找到bin/lcdata.xml文件,定位到 <local name = "zh_CN" encoding = "UTF-8" ..
将encodding 改为UTF-8
