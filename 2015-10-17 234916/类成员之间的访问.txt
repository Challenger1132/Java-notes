1、<重要>
一个类方法中的局部变量不能被该类中的其他方法访问
一个类方法中的局部变量不能被另外一个类中的方法访问
同一个类中，访问控制符是透明的，各成员之间可以相互访问

一个类中成员访问另一个类中的成员，除私有成员不能访问之外，
其他成员都可以相互访问，前提是要在一个类中定义另一个类的对象，
通过类名对象名点成员变量名的方式进行访问，包括
一个类中的属性访问另一个类中的属性，一个类中的方法访问另一个类中的方法
一个类中的方法访问另一个类中的属性
例如类A和类B，现在类B要访问类A中的成员，要在类B中定义类A的对象(A aa = new A();)aa,
在类B中通过对象aa访问类A中的成员，aa.i、aa.f()等等，
<important>而不能在类B中直接调用类A中的成员
    也就是将一个类对象作为另一个类的属性  
	在类B中 A aa = new A();就是将类A的对象aa定义为类B的对象
一个类中的成员访问另一个类中的成员，要在一个类中生成另一个类的对象，
在该类中通过类名点成员变量名的方式进行访问，不能在该类中直接调用另一个类中的成员
也就是将一个类定义为另一个类的属性
但是两个类中的成员都要访问同一个类中的成员呢？类B、C都要访问类A中的成员，
在类B、C中都要生成类A的对象aa，将类A的对象定义为类B、C的属性，但是B、C中的类A对象
是同一对象吗？    答案不是  要实现就要添加额外代码
这里两个类中的成员都访问同一个类A中的成员，这两个类中都定义了类A
的对象，通过类对象的方式进行访问，也就是在一个类中定义另一个类的属性，
但是这两个类中的A对象不是同一个对象

提供的实现方式是什么呢？类B C要访问类A成员
将一个类C作为另一个类A的内部类，内部类可以访问外部类所有的成员，在类C中就可以
访问类A中的成员，而在类B中定义类A的对象，将类A对象定义为类B的属性，在类B中也可以访问
类A中的成员
两个类都定义要访问类的对象，也就是将要访问的类对象定义为两个类的属性，
类名访问  和  类对象访问
	
	
class A 
{
	public int i = 777;
	int j = 888;
	public void f()
	{
		g();  //同类中的方法访问 同类中的方法		
		int i = 10;
		System.out.printf("i = %d\n",i);//输出的是f()方法的局部变量i
	}
	public void g()
	{
		i = 999; //同类中的方法访问同类中的属性
		System.out.printf("i = %d\n",i);//输出的是属性i
	}
}
class B 
{
	A aa = new A();
	int i = aa.i;//一个类中的属性访问另一个类中的属性
	public void f()
	{
		aa.f();  //一个类中的方法访问另一个类中的方法
		System.out.printf("i = %d\n",aa.i);//一个类中的方法访问另一个类中的属性
		System.out.printf("i = %d\n",i); //访问同类中的属性值
	}
}
----------------------------------------------------------------------
一个类方法中的局部变量不能被该类中的其他方法访问
一个类方法中的局部变量不能被另外一个类中的方法访问
可以将该变量定义为类的属性，在一个类A内部所有方法都能访问该变量(类内部访问控制符是透明的)，
不同类中，可以在该类中定义类A的对象，通过类A的对象能访问，
(已经将该变量声明为类的属性的)该变量(被private修饰的属性除外)
也就是也就是将一个类对象作为另一个类的属性
<重要>如何在一个类B中获取另一个类A中的成员，在类B中定义类A的对象，通过A的对象获取类A的属性
但是如果两个类都获取类A的成员呢？两个类中定义的类A的对象不是同一个对象？？？？

<重要>访问控制符是修饰类的成员的而不是修饰类的，静态非静态也是修饰类的成员的
访问控制符除public之外其他的都不能加在类之前，内部类之前可以加访问控制符

<重要>类的属性值和局部变量值是不一样的，类的属性值属于类的成员，局部变量值是函数的
局部变量，两者可以同名，在内存中占用不同的存储空间
 <重要>  加不加类型标识符
f()方法中的i是局部变量i，属于函数的局部变量,是重新声明的i
g()方法中的i是属性i,属于类的成员，是对类属性i的访问
在g()方法中也不能访问f()方法中的局部变量i
class A 
{
	public int i = 1;
	public void f()
	{
		int i = 2;  //这里的i是局部变量i，属于函数的局部变量,f()方法中的i是重新声明的i
	}
	public void g() //这里的i是属性i,属于类的成员，g()方法中的i是对类属性i的访问
				    //在g()方法中也不能访问f()方法中的局部变量i
	{
		i = 100;
	}
}
<重要>函数重写(覆盖)，子类继承了父类中的f()方法，子类中若没有将该方法重写
从父类继承来的f()方法会存在，只是没有显示出来而已
一个类继承父类，对父类中f()方法进行重写，要保证方法头相同，才能将父类中f()方法覆盖掉
如果方法头不一样，子类就有两个f()方法，一个是从父类继承的f()方法(没有被覆盖掉的)，
一个是自己定义的f()方法，但是类中又不允许有两个f()方法(又不满足重载的条件)，所以编译就会报错
class A 
{
	public void f()
	{
		System.out.println("AAAA");
	}
}
class B extends A 
{
	public void g()//该方法头与父类f()方法的方法头不一样，所以不能将父类中f()方法
				   //进行覆盖，子类从父类中继承的f()方法并未消失
				   //g()方法就是子类自己定义的一个方法
	{
		System.out.println("BBBB");
	}
}

<重要>this指针的用法，特别是构造方法中的this指针，什么是指向当前正在创建的对象？
指向在另外一个类中创建类的A的对象aa1(当前正在创建的对象)，
也就是另外一个类中new出的类A的对象 A aa = new A();会自动调用类A的构造方法
每一个非静态的方法内都隐含一个参数this指针，
普通方法中，this指针就指向当前调用该方法的对象，也就是说this在某个方法中，
这个方法中的this就指向调用该方法的类对象
<重要>
class Button
{
	public void f()
	{
		this  //this指向的是一个Button对象
	}
}
f()方法中的this就指向调用该f()方法的类对象(就是类Button的对象)
class Button
{
	public int i;
	public void g()
	{
		......
	}
	class  MyButton  ..
	{
		public void f()
		{
			......//this  or  Button.this
		}
	}
}
首先MyButton类是一个内部类
内部类中f()方法中的this指针指向的是一个MyButton对象(也就是包含该语句的最近的类对象)
若想是this指针指向外部类对象，指向Button对象，应该修改为Button.this

构造方法中，this代表当前正在创建的对象，将形参i赋予了当前正在创建对象中的属性i
public void show()----> public void show(A *this)//show()方法里面隐含有this指针
aa1.show();----> aa1.show(aa1);//将指针aa1赋予了show()方法的形参this指针
class A
{
	public int i = 100;
	public A(int i)//构造方法
	{
		this.i = i;//this代表当前正在创建的对象，将形参i赋予了当前正在创建对象中的属性i
		//将形参i赋予this指针指向的堆中的那块真正存储空间的i变量
		//类A的构造方法中有this.i = i;那么类A构造函数中的this
		//就指向在另外一个类中创建类的A的对象aa1(当前正在创建的对象)	
	}
}