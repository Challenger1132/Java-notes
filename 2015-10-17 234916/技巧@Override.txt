/*
@Override  有时候方法名会很长，容易写错在方法前面加@Override会交给编译器来检查，
表明下面的方法是对父类方法的重写,而不是自己定义的
一个类继承父类，对父类中f()方法进行重写，要保证方法头相同，才能将父类中f()方法覆盖掉
如果方法头不一样，子类就有两个f()方法，一个是从父类继承的f()方法(没有被覆盖掉的)，
一个是自己定义的f()方法，但是类中又不允许有两个f()方法(又不满足重载的条件)，编译会报错
*/
class A 
{
	public void f()
	{
		System.out.println("AAAA");
	}
}
class B extends A 
{
	@Override
	public void f()  //类B继承了父类A，这里是f()方法是对父类f()方法的重写，重写要保持方法头相同
					 //(方法名、参数列表、函数返回值)，其实子类有两个f()方法，一个是本身重写
					 //一个是冲父类继承而来,如果改变子类中f()方法的返回值，再次调用f()方法
					 //会报错，这就说明类B中有两个f()方法，一个来自自己写，一个是来自父类继承
					 //还可以理解为如果方法头不相同，这无法覆盖从父类中继承的方法
	{
		System.out.println("BBBB");
	}
}
class TestOverride
{
	public static void main(String[] args)
	{
		A aa = new B();//将子类对象对象发送给父类引用,通过父类引用调用子类从父类继承(继承后重写)的方法
		aa.f();
	}
}