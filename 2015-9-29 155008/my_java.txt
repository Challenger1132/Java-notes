/*
0、创建一个类，就是一个数据类型
1、<重要>
一个类方法中的局部变量不能被该类中的其他方法访问
一个类方法中的局部变量不能被另外一个类中的方法访问
同一个类中，访问控制符是透明的，各成员之间可以相互访问

一个类中成员访问另一个类中的成员，除私有成员不能访问之外，
其他成员都可以相互访问，前提是要在一个类中定义另一个类的对象，
通过类名或者类对象名点成员变量名的方式进行访问，包括
一个类中的属性访问另一个类中的属性，一个类中的方法访问另一个类中的方法
一个类中的方法访问另一个类中的属性
例如类A和类B，现在类B要访问类A中的成员，要在类B中定义类A的对象(A aa = new A();)aa,
在类B中通过对象aa访问类A中的成员，aa.i、aa.f()等等，
<important>而不能在类B中直接调用类A中的成员
    也就是将一个类对象作为另一个类的属性  
	在类B中 A aa = new A();就是将类A的对象aa定义为类B的属性
一个类中的成员访问另一个类中的成员，要在一个类中生成另一个类的对象，
在该类中通过类名点成员变量名的方式进行访问，不能在该类中直接调用另一个类中的成员
也就是将一个类定义为另一个类的属性
但是两个类中的成员都要访问同一个类中的成员呢？类B、C都要访问类A中的成员，
在类B、C中都要生成类A的对象aa，将类A的对象定义为类B、C的属性，但是B、C中的类A对象
是同一对象吗？    答案不是  要实现就要添加额外代码
--------------------------------------------------------------------------
Monitor要访问TF类中的成员，但是在Monitor类中没有生成TF类的对象，即
TF类对象没有定义为Monitor类的属性，而是在Monitor类用TF类的类名来访问TF类成员

	Monitor mm = new Monitor(this);
			.
			.
			.
	public TF aa = null;  //
	public Monitor(TF aa) //					
	{
		this.aa = aa;//
	}
构造方法中的形参aa就是Monitor类的参数this，this指向当前调用方法的对象，也就是调用
launch()方法的TF类对象，通过构造方法将形参aa赋予赋予Monitor类的属性aa,因此在Text_5
类中的main方法中生成的TF对象和Monitor类中的定义的TF类的对象是同一对象

this指向当前调用方法的对象，也就是调用launch()方法的TF类对象，将该对象发送给
Monitor类的构造方法的形参aa，构造方法中又将形参aa赋予类的属性aa，因此Monitor类
中的属性TF类对象就是Text_5类中的main方法中生成的TF对象，是同一对象
---------------------------------------------------------------------------
将实现交由一个类来实现，并不都在主方法之中，这样程序逻辑更加清楚	
提供的实现方式是什么呢？类B C要访问类A成员
将一个类C作为另一个类A的内部类，内部类可以访问外部类所有的成员，在类C中就可以
访问类A中的成员，而在类B中定义类A的对象，将类A对象定义为类B的属性，在类B中也可以访问
类A中的成员
两个类都定义要访问类的对象，也就是将要访问的类对象定义为两个类的属性，
类名访问  和  类对象访问	
class A 
{
	public int i = 777;  //类A的属性i
	int j = 888;
	public void f()
	{
		g();  //同类中的方法访问 同类中的方法		
		int i = 10;  //方法f()的局部变量i
		System.out.printf("i = %d\n",i);//输出的是f()方法的局部变量i
	}
	public void g()
	{
		i = 999; //同类中的方法访问同类中的属性
		System.out.printf("i = %d\n",i);//输出的是属性i
	}
}
class B 
{
	A aa = new A();
	int i = aa.i;//一个类中的属性访问另一个类中的属性
	public void f()
	{
		aa.f();  //一个类中的方法访问另一个类中的方法
		System.out.printf("i = %d\n",aa.i);//一个类中的方法访问另一个类中的属性
		System.out.printf("i = %d\n",i); //访问同类中的属性值
	}
}
----------------------------------------------------------------------
一个类方法中的局部变量不能被该类中的其他方法访问
一个类方法中的局部变量不能被另外一个类中的方法访问
可以将该变量定义为类的属性，在一个类A内部所有方法都能访问该变量(类内部访问控制符是透明的)，
不同类中，可以在该类中定义类A的对象，通过类A的对象能访问，
(已经将该变量声明为类的属性的)该变量(被private修饰的属性除外)
也就是也就是将一个类对象作为另一个类的属性
<重要>如何在一个类B中获取另一个类A中的成员，在类B中定义类A的对象，通过A的对象获取类A的属性
但是如果两个类都获取类A的成员呢？两个类中定义的类A的对象不是同一个对象？？？？

<重要>访问控制符是修饰类的成员的而不是修饰类的，静态非静态也是修饰类的成员的
访问控制符除public之外其他的都不能加在类之前，内部类之前可以加访问控制符
内部类可以看成外部类的成员
<重要>类的属性值和局部变量值是不一样的，类的属性值属于类的成员，局部变量值是函数的
局部变量，两者可以同名，在内存中占用不同的存储空间
 <重要>  加不加类型标识符
f()方法中的i是局部变量i，属于函数的局部变量,是重新声明的i
g()方法中的i是属性i,属于类的成员，是对类属性i的访问
在g()方法中也不能访问f()方法中的局部变量i
class A 
{
	public int i = 1; //属性i，成员
	public void f()
	{
		int i = 2;  //这里的i是局部变量i，属于函数的局部变量,f()方法中的i是重新声明的i，有类型标识符
	}
	public void g() //这里的i是属性i,属于类的成员，g()方法中的i是对类属性i的访问
				    //在g()方法中也不能访问f()方法中的局部变量i
	{
		i = 100;
	}
}
<重要>函数重写(覆盖)，子类继承了父类中的f()方法，子类中若没有将该方法重写
从父类继承来的f()方法会存在，只是没有显示出来而已    存而未现
一个类继承父类，如果将继承自父类中的f()方法进行重写，要保证方法头相同，才能将父类中f()方法覆盖掉
如果方法头不一样，子类就有两个f()方法，一个是从父类继承的f()方法(没有被覆盖掉的)，
一个是自己定义的f()方法，但是类中又不允许有两个f()方法(又不满足重载的条件)，所以编译就会报错
子类继承父类，会继承父类的属性和方法，继承成功，父类的属性和方法已经存在子类中，会“存而未现”
class A 
{
	public void f()
	{
		System.out.println("AAAA");
	}
}
class B extends A 
{
	public void g()//该方法头与父类f()方法的方法头不一样，所以不能将父类中f()方法
				   //进行覆盖，子类从父类中继承的f()方法并未消失
				   //g()方法就是子类自己定义的一个方法
	{
		System.out.println("BBBB");
	}
}
class Test
{
	public static void main(String[] args)
	{
		A aa = new A();
		B bb = new B();
		aa.f();  //访问类A中的成员
		bb.g();  //访问类B中的成员
		bb.f();  //B类继承A类，虽然在B类中并没有显示，但继承的f()方法在B类中并未消失，在main()方法中还可以访问
	}
}

<重要>this指针的用法，特别是构造方法中的this指针，什么是指向当前正在创建的对象？
指向在另外一个类中创建类的A的对象aa1(当前正在创建的对象)，
也就是另外一个类中new出的类A的对象 A aa = new A();会自动调用类A的构造方法
每一个非静态的方法内都隐含一个参数this指针，
普通方法中，this指针就指向当前调用该方法的对象，也就是说this在某个方法中，
这个方法中的this就指向调用该方法的类对象
<重要>
class Button
{
	public void f()
	{
		this  //this指向的是一个Button对象
	}
}
f()方法中的this就指向调用该f()方法的类对象(就是类Button的对象)
class Button
{
	public int i;
	public void g()
	{
		......
	}
	class  MyButton  ..
	{
		public void f()
		{
			......//this  or  Button.this
		}
	}
}
首先MyButton类是一个内部类
内部类中f()方法中的this指针指向的是一个MyButton对象(也就是包含该语句的最近的类对象)
若想是this指针指向外部类对象，指向Button对象，应该修改为Button.this

构造方法中，this代表当前正在创建的对象，将形参i赋予了当前正在创建对象中的属性i
public void show()----> public void show(A *this)//show()方法里面隐含有this指针
aa1.show();----> aa1.show(aa1);//将指针aa1赋予了show()方法的形参this指针
class A
{
	public int i = 100;
	public A(int i)//构造方法
	{
		this.i = i;//this代表当前正在创建的对象，将形参i赋予了当前正在创建对象中的属性i
		//将形参i赋予this指针指向的堆中的那块真正存储空间的i变量
		//类A的构造方法中有this.i = i;那么类A构造函数中的this
		//就指向在另外一个类中创建类A的对象aa1(当前正在创建的对象)	
	}
}
2、抽象类和接口都需要子类来实现
3、封装成类，封装成函数，封装成工具，封装成方法
4、多态一个很重要的例子
public void f(A aa)  //类A是定义的某种数据类型
{
	aa.f();
}
在多态的机制中，可以将一个类对象赋予方法f()的形参，
从而实现通过传进来的对象去调用f()方法，只要传进来的对象
是类A的对象就行，在多态机制中，可以将类A的子类对象赋予aa，在一个
类族中将子类或者子类的子类对象赋予父类引用，从而实现调用类族中
所有的f()方法
5、@Override  有时候方法名会很长，容易写错在方法前面加@Override会交给编译器来检查，
表明下面的方法是对父类方法的重写,而不是自己定义的
6、抽象类和接口不能通过new造出对象，但可以生成抽象类或者接口的引用，可以将
抽象类或接口的实现类对象发送给该引用，达到多态的目的
7、论方法的形参类型，在C中形参类型是int、char、struct node *、int *等等
在Java中方法的形参类型与此类似，是A、Object、Thread等等，
这些都是类或者用户自定义类是自定义的数据类型 
在C中数据类型是有限的种类，，在Java中可以定义任何的数据类型
8、类Thread类Exception等等都是Java封装好的类而已，具有类的一般属性
不要将他们看成什么非常特殊的类
9、子类继承了父类，并重写了父类中的f()方法，父类中的f()没有抛出异常
则子类中的f()也不能抛出异常，或者一个类实现了某个接口中的f()方法，
接口中的该f()方法没有抛出异常，则实现该接口的类中的方法也不能抛出异常
因为子类抛出异常的范围不能比父类大，(捕获的时候要先捕获子类异常，再捕获父类异常
否则，会造成后面捕获子类异常语句失效)，所有要捕获处理的异常都可以用
Exception类对象进行接收，相当于父类对象接收，如果子类抛出异常的范围比父类大
则Exception类对象(父类对象)就不能接收，多态的知识，接口也可以实现多态
      例如，Thread类中的sleep()方法会抛出InterruptedException异常，该异常必须进行捕获处理
类A实现了Runnable接口中的run()方法，接口(相当于父类)中的run方法没有抛出异常，
所以类A(相当于子类)中的run()方法也不能抛出异常，因为子类抛出异常的范围不能比父类大
10、****多态一段代码实现类族中所有f()方法的调用  
论方法的形参     抽象方法的继承，接口，不能new出对象   
异常处理方式throws   线程相关开辟线程的两种方式，
无论是继承了Thread类中的run()方法还是实现了runnable接口中的run()方法都不能抛出异常 流  
11、有的接口没有任何方法，这类接口一般是标记接口,一个类实现了Serializable接口
潜在含义是告诉编译器这个类是可以被序列化的，如果程序中存在相应的代码，就会完成相应的处理
如果该类没有实现Serializable接口，但程序中却存在序列化该类的代码，编译就会报错
12、class A extends WindowAdapter implements ActionListener  
注意要先继承后实现
java中的方法第一个字母是小写，后面的每个单词的字母是大写
13、在创建类对象的同时会自动调用类的构造方法(有参的后者无参的)
一个类可以定义多个构造方法，有参的无参的，体现了构造方法的重载
al.add(new Stu("张三",22));//在创建类对象的同时会自动调用类的有参的构造方法，同时完成类对象的初始化，
如果用户没有定义构造方法，编译系统会自动生成无参的构造方法，一旦用户定义一个构造方法
默认的构造方法不会出现，如果只定义了有参的构造方法，在创建类对象的时候要  用，否则会报错
除非类中还有其他的构造方法
生成类的对象的时候只调用其中的一个构造方法
只能在子类构造方法中通过super语句调用父类的构造方法，且构造方法不能被继承
14、子类继承父类，会继承父类的属性和方法，继承成功，父类的属性和方法已经存在子类中
只是存而未现而已，在子类中可以通过构造函数对继承而来的成员进行初始化，
还可以在另一个类中生成该类的类对象，调用继承过来的成员
构造方法不能被继承、父类成员被private修饰，子类无法继承，这些成员在子类中也不存在
15、		 public int j = 100;					String str = new String("hello world");
		 Integer i = new Integer(j);			A aa = new A();
		 要区别于C语言中的写法，不要以为是赋值，这里的i、srr、aa都是类对象，存放在栈中，都是某种数据类型
		 占据8个字节，存放的是new出空间的地址，是静态指针变量，是引用
基本数据类型 int、float、byte、double、char
引用数据类型：
所有自定义的类的变量，本身都不存放数据，数据本身存放在堆区，
相当于地址，指针，静态指针变量，引用
数组的名字
接口定义的变量
16、DataOutputStream dos = new DataOutputStream(baos);
对于自定义的类，类的构造方法，在生成类对象的时候自动调用构造方法，完成类对象的初始化
Java中的类，new....也会自动调用类的构造方法完成类对象的初始化

17、使用new生成类的对象，生成类对象成功，会为类的所有成员分配相应的存储空间，
这些存储空间称为类对象的实体，并返回该存储空间的引用赋予类对象
只声明了类的对象，并不会为类中成员分配存储空间，这个对象是空对象，因为里面没有对象的实体，
只有通过new关键字，才会为类中成员分配存储空间
通过new关键字会生成不同的类对象，不同对象的实例变量在内存中占用不同的存储空间，

当类的字节码加在到内存中时，如果该类没有创建类对象，类的实例变量不会分配内存空间，
类的实例方法不会分配入口地址，创建类对象成功才会为类的实例变量分配内存空间，为类的实例方法
分配入口地址，通过new关键字会生成不同的类对象，不同对象的实例变量在内存中占用不同的存储空间，
但创建类对象时为实例方法分配入口地址，再次创建该类的对象的时候，不再分配入口地址，
实例方法为类对象所共有
但是当类的字节码加在到内存中时，就会为类变量分配存储空间，为类方法分配入口地址
      被static修饰的成员是静态成员但是类变量属于类本身，为类的所有对象所共有，
可以通过类名的方式进行访问，所有对象的类变量占用相同的一块内存空间，
改变一个类对象的类变量会影响到其他对象中的类变量
非静态成员可以访问静态成员，静态成员不能访问非静态成员，静态成员可以访问静态成员
类方法不能访问实例变量，也不能调用实例方法，因为在类对象没有创建之前，实例变量没有
分配存储空间，实例方法没有分配入口地址
18、Java中有垃圾回收机制，这种机制周期性的检测某个实体是否已经不被所有的对象
所拥有，如果发现这样的实体，该实体所占的存储空间就会被释放
19、子类可以通过对父类成员变量的隐藏和方法的重写，将父类的状态和行为改变为自己的状态和行为
子类继承父类，子类中定义的属性成员和继承自父类的属性成员名相同，则继承自父类的成员被隐藏
子类中的方法名和继承自父类的方法同名，是对继承自父类的方法的重写
如果要在子类中使用被隐藏被重写的父类成员，要使用super关键字
20、抽象类  &&  接口
有抽象方法的类一定是抽象类，抽象类不一定有抽象方法，一个类继承抽象类，必须将抽象类
中的所有抽象方法实现，可以空实现，只加花括号，没有具体的语句，否则该类要声明为abstract
没有方法体的方法是抽象方法，抽象类不关心具体的行为，具体的行为由子类负责实现
接口是更为严格的抽象类
<important>
接口的存在在于接口可以增加许多类都需要实现的功能,接口只强调具体的功能
不同类可以实现相同的接口，一个类也可以实现不同的接口，接口只强调具体的功能，不关心功能的具体实现过程
一个类实现了某个接口要给出接口方法的具体实现，也就是给接口中的所有方法添加方法体

抽象类和接口不能通过new造出对象，但可以生成抽象类或者接口的引用，可以将抽象类
或接口的实现类类对象赋予该引用，这是多态机制
用该引用调用继承了抽象类或者实现了某个接口的子类中的方法，但是要注意，
这些方法是继承自父类，或对父类方法的重写，或者实现了接口的方法，子类中特有的成员还是不能通过该引用来访问
21、<重要>
在一个类(A)内部可以定义另一个类的类对象，该类对象就属于该类(A)的成员(属性)
在一个类(A)的方法内部，也可以定义另一个类的类对象，该类对象就属于该类(A)方法内的局部变量，
这些类和基本数据类型是等价的 TextField ---> int  A ----> float
class A
{
	public int i; //属性，成员 
	public void f()
	{
		int i; //类A中f()方法中的局部变量
	}
}
class A 
{
	public TextField text1; //text1是属性，成员
	public void f()
	{
		TextField text2;// text2是类A中f()方法中的局部变量
	}
} 
只是int和TextField都是数据类型，是等价的，不要对int有先入为主的观念
例如在一个类内部或者类内部的方法中定义 TextField text1; Button button; Frame f;
Thread thread; String str; int i; float f;等等都是等价的，都可以看成是各种形式的数据类型

text1是在类中定义的另一个类的类对象,属于类的成员
text2在一个类A的方法f()内部，定义另一个类的类对象，属于方法中的局部变量

class TF
{
	Button button;
	Frame f;
	public void launch()
	{
		//Frame f1 = new Frame(); //f1是局部变量，属于方法黑匣子内部的局部变量
		f = new Frame()；        //f是类的属性值，属于类成员,前面没有类型标识符(Frame)
		button = new Button();
	}
}
---------------------------------------------------------------------------------------
变量能够被同类中的方法访问，能够被另一个类中的方法访问，要将该变量定义为类的属性
同类中访问控制符是透明的，各个成员可以相互访问，直接进行访问
不同类中成员之间的访问，要在该类中定义另一个类的类对象，通过该类对象进行访问，或者将另一个类的类对象
定义为该类的属性成员，而不能直接对另一个类中的成员进行访问

两个类要访问同一个类中的成员，要在两个类中都定义另一个类的类对象，或者将
要访问的类的类对象定义为两个类的属性，如何保证在两个类中定义的另一个类的
类对象是同一个类对象？通过this指针构造方法等来实现

ButtonListener类中的成员要访问TF类中的成员，要在ButtonListener类中定义TF类的类对象tf，
通过类对象tf去访问TF类的成员，而不能在ButtonListener类内部直接访问TF类的成员
同时TF类中的成员也要访问ButtonListener类中的成员，要在TF类中定义ButtonListener类的类对象listener，
通过类对象listene去访问ButtonListener类的成员，而不能在TF类内部直接访问ButtonListener类的成员
启动类TestTextField_1中的main方法成员也要访问TF类中的成员，要在TestTextField_1类中
定义TF类的类对象tf，如何保证TestTextField_1类中的TF类对象tf和ButtonListener类中的TF类对象tf
是同一个对象？
---------------------------------------------------------------------------------------
22、内部类可以直接访问外部类的成员，不需要在内部类中生成外部类的类对象，
但是外部类不能直接访问内部类成员，和不同类之间成员的访问一样
外部类要想访问内部类成员，要在外部类中生成内部类的类对象，而不能直接访问内部类成员
-----------------------------
！不同类之间相互访要在一个类中生成另一个类的类对象，通过类对象来访问另一个类的成员
当有两个类要访问同一个类（A）的成员时，要在两个类中都生成该类的类对象（引用），要保证指向的是同一个对象
要用this指针，(一个类中new出要访问类的类对象，另一个类中只生成要访问类的引用，并不new出对象)，
这样就可以保证操作的是一个类的同一对象，如果只有其中一个类要访问类A，另一个类并不访问，
则另一个类中并不需要生成类A的对象
一个类中new出对象，另一个类中只生成要访问类的引用，并不new出对象,但是另一个可以new出对象吗？
这要取决于我们要生成类对象的类中是否有构造方法，如果有，new出对象的同时会调用相应的构造方法，指向结果和
预期不一样，如果没有构造方法，可以new出对象，但最终也会被构造方法再次改变
！！<important>
但是内部类时，由于内部类可以直接访问外部类的成员，不需要在内部类中生成外部类的类对象，因此就没有指向
同一个类对象的问题，因而就不需要this指针
同时A类要访问B类中的成员，要在A类中生成B类的类对象，或者将B类的类对象作为A类的引用，若B类不访问A类成员
不需要在B类中生成A类的类对象
23、一个类实现某个接口，必须给出该接口中所有抽象方法的实现，即必须实现（重写）接口中所有的抽象方法
（可以空实现，只加括号，里面不写具体的实现过程，实现方法）即使不准备用接口中的某个方法
上面程序不报错，说明已经将WindowListener中的所有抽象方法已经实现了，即使有其中一个方法没有实现也会报错
适配器可以代替接口处理事件，当接口中有超过一个抽象方法时，Java会提供一个适配器，
只需重写需要的方法即可
24、一个类实现某个接口，必须给出该接口中所有抽象方法的实现，即必须实现(重写)接口中所有的抽象方法
(可以空实现，只加括号，里面不写具体的实现过程，实现方法)即使你不准备用接口中的某些方法
实现了某个接口的类，重写了接口中的方法，这些方法是如何调用的呢？
一个类实现了ActionListener接口，要重写里面的actionPerformed()方法、
一个类实现了Runnable接口，要重写里面的Run()方法、
一个类实现了Comparable接口，要重写里面的compareTo()方法、
一个类实现了FileMameFilter接口，要重写里面的accept()方法，但是这些接口中的方法是如何调用的呢？
一个类对象调用某个方法，该方法的形参是实现了某个接口的类对象，在该类对象中给出了接口中抽象
方法的实现
25、Wind类继承了Frame，本身就具有了Frame的性质，可以在Wind类的构造方法中直接添加对象,直接写方法等等，
前面不需要再通过类对象来调用
一个类继承了某个类就具有了父类的性质，可以在该类中的构造方法中直接添加对象，直接写要调用的方法等
		注意下面两种方式的区别
		class Wind   //这里Wind类中的构造方法写的形式和Wind类继承了Frame类的构造方法中的写法不一样
		{
			public TextArea text;
			public Frame frame;
			public Wind(String s)
			{
				super(s);
				frame = new Frame();
				text = new TextArea();
				frame.setLayout(new FlowLayout());
				frame.add(text);
				frame.setBounds(200,200,300,300);
				frame.setVisible(true);
				frame.validate();
				frame.addWindowListener(this);
			}
		}
		------------------------------------------------------
		class Wind extends Frame //Wind类本身就具有Frame的性质，可以在构造方法中直接添加对象，直接调用方法等等
		{
			public TextArea text;
			public Wind(String s)
			{
				super(s);
				text = new TextArea();
				setLayout(new FlowLayout());
				add(text);
				setBounds(200,200,300,300);
				setVisible(true);
				validate();
			}
		}
26、main()方法也是方法，在方法中定义的变量是局部变量，不是类的属性，因此变量前面不能加访问控制符
访问控制符是用来修饰类的成员的

*/
