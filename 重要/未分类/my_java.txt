/*
0、创建一个类，就是一个数据类型
1、<重要>
一个类方法中的局部变量不能被该类中的其他方法访问
一个类方法中的局部变量不能被另外一个类中的方法访问
同一个类中，访问控制符是透明的，各成员之间可以相互访问

一个类中成员访问另一个类中的成员，除私有成员不能访问之外，
其他成员都可以相互访问，前提是要在一个类中定义另一个类的对象，
通过类名或者类对象名点成员变量名的方式进行访问，包括
一个类中的属性访问另一个类中的属性，一个类中的方法访问另一个类中的方法
一个类中的方法访问另一个类中的属性
例如类A和类B，现在类B要访问类A中的成员，要在类B中定义类A的对象(A aa = new A();)aa,
在类B中通过对象aa访问类A中的成员，aa.i、aa.f()等等，
<important>而不能在类B中直接调用类A中的成员
    也就是将一个类对象作为另一个类的属性  
	在类B中 A aa = new A();就是将类A的对象aa定义为类B的属性
一个类中的成员访问另一个类中的成员，要在一个类中生成另一个类的对象，
在该类中通过类名点成员变量名的方式进行访问，不能在该类中直接调用另一个类中的成员
也就是将一个类定义为另一个类的属性
但是两个类中的成员都要访问同一个类中的成员呢？类B、C都要访问类A中的成员，
在类B、C中都要生成类A的对象aa，将类A的对象定义为类B、C的属性，但是B、C中的类A对象
是同一对象吗？    答案不是  要实现就要添加额外代码
--------------------------------------------------------------------------
Monitor要访问TF类中的成员，但是在Monitor类中没有生成TF类的对象，即
TF类对象没有定义为Monitor类的属性，而是在Monitor类用TF类的类名来访问TF类成员

	Monitor mm = new Monitor(this);
			.
			.
			.
	public TF aa = null;  //
	public Monitor(TF aa) //					
	{
		this.aa = aa;//
	}
构造方法中的形参aa就是Monitor类的参数this，this指向当前调用方法的对象，也就是调用
launch()方法的TF类对象，通过构造方法将形参aa赋予赋予Monitor类的属性aa,因此在Text_5
类中的main方法中生成的TF对象和Monitor类中的定义的TF类的对象是同一对象

this指向当前调用方法的对象，也就是调用launch()方法的TF类对象，将该对象发送给
Monitor类的构造方法的形参aa，构造方法中又将形参aa赋予类的属性aa，因此Monitor类
中的属性TF类对象就是Text_5类中的main方法中生成的TF对象，是同一对象
---------------------------------------------------------------------------
将实现交由一个类来实现，并不都在主方法之中，这样程序逻辑更加清楚	
提供的实现方式是什么呢？类B C要访问类A成员
将一个类C作为另一个类A的内部类，内部类可以访问外部类所有的成员，在类C中就可以
访问类A中的成员，而在类B中定义类A的对象，将类A对象定义为类B的属性，在类B中也可以访问
类A中的成员
两个类都定义要访问类的对象，也就是将要访问的类对象定义为两个类的属性，
类名访问  和  类对象访问	
class A 
{
	public int i = 777;  //类A的属性i
	int j = 888;
	public void f()
	{
		g();  //同类中的方法访问 同类中的方法		
		int i = 10;  //方法f()的局部变量i
		System.out.printf("i = %d\n",i);//输出的是f()方法的局部变量i
	}
	public void g()
	{
		i = 999; //同类中的方法访问同类中的属性
		System.out.printf("i = %d\n",i);//输出的是属性i
	}
}
class B 
{
	A aa = new A();
	int i = aa.i;//一个类中的属性访问另一个类中的属性
	public void f()
	{
		aa.f();  //一个类中的方法访问另一个类中的方法
		System.out.printf("i = %d\n",aa.i);//一个类中的方法访问另一个类中的属性
		System.out.printf("i = %d\n",i); //访问同类中的属性值
	}
}
----------------------------------------------------------------------
一个类方法中的局部变量不能被该类中的其他方法访问
一个类方法中的局部变量不能被另外一个类中的方法访问
可以将该变量定义为类的属性，在一个类A内部所有方法都能访问该变量(类内部访问控制符是透明的)，
不同类中，可以在该类中定义类A的对象，通过类A的对象能访问，
(已经将该变量声明为类的属性的)该变量(被private修饰的属性除外)
也就是也就是将一个类对象作为另一个类的属性
<重要>如何在一个类B中获取另一个类A中的成员，在类B中定义类A的对象，通过A的对象获取类A的属性
但是如果两个类都获取类A的成员呢？两个类中定义的类A的对象不是同一个对象？？？？

<重要>访问控制符是修饰类的成员的而不是修饰类的，静态非静态也是修饰类的成员的
访问控制符除public之外其他的都不能加在类之前，内部类之前可以加访问控制符
内部类可以看成外部类的成员
<重要>类的属性值和局部变量值是不一样的，类的属性值属于类的成员，局部变量值是函数的
局部变量，两者可以同名，在内存中占用不同的存储空间
 <重要>  加不加类型标识符
f()方法中的i是局部变量i，属于函数的局部变量,是重新声明的i
g()方法中的i是属性i,属于类的成员，是对类属性i的访问
在g()方法中也不能访问f()方法中的局部变量i
class A 
{
	public int i = 1; //属性i，成员
	public void f()
	{
		int i = 2;  //这里的i是局部变量i，属于函数的局部变量,f()方法中的i是重新声明的i，有类型标识符
	}
	public void g() //这里的i是属性i,属于类的成员，g()方法中的i是对类属性i的访问
				    //在g()方法中也不能访问f()方法中的局部变量i
	{
		i = 100;
	}
}
<重要>函数重写(覆盖)，子类继承了父类中的f()方法，子类中若没有将该方法重写
从父类继承来的f()方法会存在，只是没有显示出来而已    存而未现
一个类继承父类，如果将继承自父类中的f()方法进行重写，要保证方法头相同，才能将父类中f()方法覆盖掉
如果方法头不一样，子类就有两个f()方法，一个是从父类继承的f()方法(没有被覆盖掉的)，
一个是自己定义的f()方法，但是类中又不允许有两个f()方法(又不满足重载的条件)，所以编译就会报错
子类继承父类，会继承父类的属性和方法，继承成功，父类的属性和方法已经存在子类中，会“存而未现”
class A 
{
	public void f()
	{
		System.out.println("AAAA");
	}
}
class B extends A 
{
	public void g()//该方法头与父类f()方法的方法头不一样，所以不能将父类中f()方法
				   //进行覆盖，子类从父类中继承的f()方法并未消失
				   //g()方法就是子类自己定义的一个方法
	{
		System.out.println("BBBB");
	}
}
class Test
{
	public static void main(String[] args)
	{
		A aa = new A();
		B bb = new B();
		aa.f();  //访问类A中的成员
		bb.g();  //访问类B中的成员
		bb.f();  //B类继承A类，虽然在B类中并没有显示，但继承的f()方法在B类中并未消失，在main()方法中还可以访问
	}
}

<重要>this指针的用法，特别是构造方法中的this指针，什么是指向当前正在创建的对象？
指向在另外一个类中创建类的A的对象aa1(当前正在创建的对象)，
也就是另外一个类中new出的类A的对象 A aa = new A();会自动调用类A的构造方法
每一个非静态的方法内都隐含一个参数this指针，
普通方法中，this指针就指向当前调用该方法的对象，也就是说this在某个方法中，
这个方法中的this就指向调用该方法的类对象
<重要>
class Button
{
	public void f()
	{
		this  //this指向的是一个Button对象
	}
}
f()方法中的this就指向调用该f()方法的类对象(就是类Button的对象)
class Button
{
	public int i;
	public void g()
	{
		......
	}
	class  MyButton  ..
	{
		public void f()
		{
			......//this  or  Button.this
		}
	}
}
首先MyButton类是一个内部类
内部类中f()方法中的this指针指向的是一个MyButton对象(也就是包含该语句的最近的类对象)
若想是this指针指向外部类对象，指向Button对象，应该修改为Button.this

构造方法中，this代表当前正在创建的对象，将形参i赋予了当前正在创建对象中的属性i
public void show()----> public void show(A *this)//show()方法里面隐含有this指针
aa1.show();----> aa1.show(aa1);//将指针aa1赋予了show()方法的形参this指针
class A
{
	public int i = 100;
	public A(int i)//构造方法
	{
		this.i = i;//this代表当前正在创建的对象，将形参i赋予了当前正在创建对象中的属性i
		//将形参i赋予this指针指向的堆中的那块真正存储空间的i变量
		//类A的构造方法中有this.i = i;那么类A构造函数中的this
		//就指向在另外一个类中创建类A的对象aa1(当前正在创建的对象)	
	}
}

只能在子类构造方法中通过super语句调用父类的构造方法，且构造方法不能被继承
14、子类继承父类，会继承父类的属性和方法，继承成功，父类的属性和方法已经存在子类中
只是存而未现而已，在子类中可以通过构造函数对继承而来的成员进行初始化，
还可以在另一个类中生成该类的类对象，调用继承过来的成员
构造方法不能被继承、父类成员被private修饰，子类无法继承，这些成员在子类中也不存在

17、使用new生成类的对象，生成类对象成功，会为类的所有成员分配相应的存储空间，
这些存储空间称为类对象的实体，并返回该存储空间的引用赋予类对象
只声明了类的对象，并不会为类中成员分配存储空间，这个对象是空对象，因为里面没有对象的实体，
只有通过new关键字，才会为类中成员分配存储空间
通过new关键字会生成不同的类对象，不同对象的实例变量在内存中占用不同的存储空间，

当类的字节码加在到内存中时，如果该类没有创建类对象，类的实例变量不会分配内存空间，
类的实例方法不会分配入口地址，创建类对象成功才会为类的实例变量分配内存空间，为类的实例方法
分配入口地址，通过new关键字会生成不同的类对象，不同对象的实例变量在内存中占用不同的存储空间，
但创建类对象时为实例方法分配入口地址，再次创建该类的对象的时候，不再分配入口地址，
实例方法为类对象所共有
但是当类的字节码加在到内存中时，就会为类变量分配存储空间，为类方法分配入口地址
      被static修饰的成员是静态成员但是类变量属于类本身，为类的所有对象所共有，
可以通过类名的方式进行访问，所有对象的类变量占用相同的一块内存空间，
改变一个类对象的类变量会影响到其他对象中的类变量
非静态成员可以访问静态成员，静态成员不能访问非静态成员，静态成员可以访问静态成员
类方法不能访问实例变量，也不能调用实例方法，因为在类对象没有创建之前，实例变量没有
分配存储空间，实例方法没有分配入口地址

18、Java中有垃圾回收机制，这种机制周期性的检测某个实体是否已经不被所有的对象
所拥有，如果发现这样的实体，该实体所占的存储空间就会被释放

抽象类和接口不能通过new造出对象，但可以生成抽象类或者接口的引用，可以将抽象类
或接口的实现类类对象赋予该引用，这是多态机制
用该引用调用继承了抽象类或者实现了某个接口的子类中的方法，但是要注意，
这些方法是继承自父类，或对父类方法的重写，或者实现了接口的方法，子类中特有的成员还是不能通过该引用来访问
21、<重要>
在一个类(A)内部可以定义另一个类的类对象，该类对象就属于该类(A)的成员(属性)
在一个类(A)的方法内部，也可以定义另一个类的类对象，该类对象就属于该类(A)方法内的局部变量，
class A
{
	public int i; //属性，成员 
	public void f()
	{
		int i; //类A中f()方法中的局部变量
	}
}
class A 
{
	public TextField text1; //text1是属性，成员
	public void f()
	{
		TextField text2;// text2是类A中f()方法中的局部变量
	}
} 
只是int和TextField都是数据类型，是等价的，不要对int有先入为主的观念
例如在一个类内部或者类内部的方法中定义 TextField text1; Button button; Frame f;
Thread thread; String str; int i; float f;等等都是等价的，都可以看成是各种形式的数据类型

text1是在类中定义的另一个类的类对象,属于类的成员
text2在一个类A的方法f()内部，定义另一个类的类对象，属于方法中的局部变量

变量能够被同类中的方法访问，能够被另一个类中的方法访问，要将该变量定义为类的属性
同类中访问控制符是透明的，各个成员可以相互访问，直接进行访问
不同类中成员之间的访问，要在该类中定义另一个类的类对象，通过该类对象进行访问，或者将另一个类的类对象
定义为该类的属性成员，而不能直接对另一个类中的成员进行访问