接口是对行为的抽象，是对功能的扩展，类想要某种功能，就去实现相应的接口，重写接口中的方法
RandomAccessFile 随机读取文件的流，但是他不属于IO流体系，其父类是Object
之前读写文件都是对于一个文件顺次的读取，不能从文件的中间进行读取
RandomAccessFile的实例支持对随机存取文件的读写。允许从文件中间位置开始读取，随机存取文件的行为类似存储在文件系统中的一个大型字节数组
存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针
RandomAccessFile不属于流体系，其父类是Object，但是融合了文件读写的功能，并支持文件的随机读写
其构造器第一个参数是File类对象或者是String类型的文件路径，第二个参数是读写方式

多线程复制文件夹中的文件，为什么没有发生线程的紊乱，(是因为是阻塞式操作？？)
多线程复制单个文件就会出现线程之间的相互干扰

要注意思考什么条件下才适合用多线程来实现？？？？
在等待用户输入的时候，这个情况下有大龄的空闲时间，代码可以跑去处理其他事情，这样环境下才适合使用多线程
多线程的优点
	资源利用率更好
		在IO阻塞的情况，或者等待用户输入的情况下，这时候有大量的空闲时间可以利用，多线程可以是空闲时间保持最低
	程序响应更快
		服务器处理用户请求，如果请求的处理是耗时操作，那么只有处理完用户的请求之后才能去监听用户的请求，多线程条件下
		可以将对请求的操纵交由其他线程处理，当前线程可以返回继续监听用户的请求；
		桌面用用程序，界面只负责用户的操作，对操作的处理放到其他线程中，这样界面还可以继续接受用户的操作，如果将
		操作的处理放到UI线程中，就会显得很"卡"，多线程的出现使应用看起来相应更快，增强了用户体验
多线程的代价
	并不是多线程的实现优于单线程的实现，要看当前环境是否适合多线程来实现
	设计更为复杂
		多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂
	上下文切换的开销，上下文切换并不廉价
		当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，
		然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为context switch"
		CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程，
		如果没有必要，应该减少上下文切换的发生
	增加资源消耗
		线程在运行的时候需要从计算机里面得到一些资源,除了CPU，线程还需要一些内存来维持它本地的堆栈
		它也需要占用操作系统中一些资源来管理线程
调用run()或者start()
Thread newThread = new Thread(MyRunnable());
newThread.run();  //should be start();
run()方法的确如你所愿的被调用了,事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了
也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行run()方法，必须调用新线程的start方法

cnt ++;操作并不是原子性的
	从内存获取cnt的值放到寄存器
	将寄存器中的值增加1
	将寄存器中的值写回内存
	
竞态条件 & 临界区
当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区

Java中资源什么时候会变成垃圾？
当不再有更多引用指向该对象的时候，该对象就会变成垃圾，该对象不会再次被引用
资源可以是对象，数组，文件，数据库连接，套接字等等，Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象

线程安全
多线程环境，共享数据，多条语句访问共享数据
	A:基本类型的局部变量是线程安全的，因为局部变量存储在线程自己的堆栈中，永远不会被其他线程访问到
	B:引用类型的局部变量，引用本身没有被共享，引用所指的对象并没有存储在线程的栈内，所有的对象都存在共享堆中，
	如果在某个方法中创建的对象不会逃逸出(即该对象不会被其它方法获得，也不会被非局部变量引用到)该方法，那么它就是线程安全的
	C:一个对象实例被多个线程同时访问时，他的成员变量就可能是线程不安全的
也就是数据是否被多个线程共同访问，若被多个线程访问，可能造成线程不安全

线程死锁，线程之间相互竞争，导致线程之间相互等待的现象，死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁
不适当地运用“synchronized”关键词来管理线程对特定对象的访问，容易造成线程的死锁


同步块儿
同步在一个对象上的同步块只能被一个线程进入并执行操作，所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出
Java实例方法同步是同步在该方法所在的实例对象上，这样，每个实例其方法同步都同步在不同的类对象上，即该方法所属的类对象
静态方法的同步是指同步在该方法所在的类对象上
实例方法中的同步块，同步到一个类对象上面，若用this，同步到调用该同步块所在方法的类对象上面
静态方法中的同步块，若用A.class作为监视器，则同步到该同步块所在静态方法所属的类对象上面
“synchronized”关键词的作用是，确保特定的代码块在某个时刻只有一个线程被允许执行，因此，
被允许执行的线程首先必须拥有对变量或对象的排他性的访问权。当线程访问对象时，线程会给对象加锁，
而这个锁导致其它也想访问同一对象的线程被阻塞，直至第一个线程释放它加在对象上的锁





