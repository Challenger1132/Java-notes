/*

为什么在子类构造中一定要调用父类构造
子类构造通过调用父类构造初始化继承自父类的成员
类似C++ 派生类构造通过调用基类构造，初始化派生类对象中的基类组成部分
Student s = new Student();做了哪些事情?
	class Student{
		private String name = "张三";
		private int age = 10;
		public Student(){
			name = "李四";
			age = 20;
		}
	}
	public Class Test {
		public static void main(String[] args) {
			Student s = new Student();
		}
	}
	把Student.class文件加载到内存
	在栈内存为 s 开辟空间
	在堆内存为对象Student()申请空间
	给Student()的成员变量进行默认初始化 name = null, age = 0
	给Student()的成员变量进行显示初始化 name = "张三", age = 10
	通过构造方法给成员变量进行再次赋值 name = "李四", age = 20
	对象构造完毕，把返回对象的引用给 s
	C++:通过构造函数初始值列表对类的属性成员进行显式初始化，如果属性成员没有在构造函数初始值列表中进行
	显式初始化，在构造函数方法体之前进行默认初始化，然后在构造函数体内对属性成员进行赋值操作，
	const成员、引用、以及没有默认构造器的成员，在构造函数初始值列表中进行初始化
成员变量和局部变量的区别
	A:在类中的位置不同
		成员变量：类中方法外
		局部变量：函数的局部位置，方法定义中或者方法声明上
	B:在内存中的位置不同
		成员变量：在堆空间中
		局部变量：在栈中
	C:生命周期不同
		成员变量：随着对象的创建而存在，随着对象的消失而消失
		局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
	D:初始化值不同
		成员变量：有默认初始值
		局部变量：没有默认值，必须先定义赋值，然后才能使用
代码块：在Java中，使用 {} 括起来的代码被称为代码块根据其位置和声明的不同，可以分为
	局部代码块:局部位置
		作用：用于限定变量的生存期
	构造代码块:在类中的成员位置,用{}括起来的代码 每次构造方法执行前，都会先执行构造代码块
		作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化
	静态代码块:在类中的成员位置,用static修饰，用{}括起来的代码
		作用：一般是对类进行初始化
	静态代码块、构造代码块、构造方法执行的顺序
	先执行静态代码块，再执行构造代码块再执行构造方法，且静态代码块只执行一次，构造代码块每次调用构造方法之前都执行
static关键字
	1、static成员随着类的加载而加载，优先于类对象而存在，被类的所有对象所共有，可以通过类名的方式进行访问
		静态变量被所有的对象所共享，在内存中只有一份
		静态成员只在类的Class对象加载到内存时初始化一次
		而非静态变量是对象所拥有的，在类对象创建的时候被初始化，存在多份，各个对象中的非静态成员互不影响
	2、普通成员变量和静态成员变量的区别：
			A:所属
				静态变量：属于类，类变量
				普通成员变量：属于类对象
			B:内存位置
				静态变量：方法区的静态区
				普通成员变量：堆空间(new 出来的对象)
			C:生存
				静态变量：静态变量是随着类的加载而加载，随着类的消失而消失
				普通成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失
			D:访问
				静态变量：可以通过对象名访问，也可以通过类名直接访问
				普通成员变量：通过对象名访问	
	
	3、静态方法中没有this,静态方法属于类，不依赖于任何对象就可以进行访问，而this依附于具体的类对象
	4、静态方法不能访问非静态方法(因为静态的东西随着类就进行了加载而存在，而非静态成员要在类对象创建的时候才存在，
	非静态的东西要依赖于具体的对象才能访问，可以理解为用存在的去访问暂时不存在的，因此是不允许的)，
	反之，非静态方法可以访问静态方法以及非静态方法
	5、对于类，每new 出一个对象，就会在堆空间中开辟一块存储空间，若类多个对象具有相同的成所员变量值，可以用关键字
	static修饰，设置为静态成员，可以节省存储空间(因为成员变量被static修饰在内存中只有一份)
	6、构造方法也属于静态方法，只是构造方法是是隐式的写了出来
	7、static代码块可用于代码优化
	7、static的修饰成员变量、成员方法，但是并不会改变被修饰对象的访问权限(被public protected private修饰的东西)
	8、静态成员只在类的Class对象加载内存时初始化一次
this和super的区别
	this代表本类对应的引用
	super代表父类存储空间的标识(可以理解为父类引用,可以操作父类的成员)
	调用成员变量
		this.成员变量 	调用本类的成员变量
		super.成员变量 	调用父类的成员变量
	调用构造方法
		this()调用本类中空参构造方法， this(...)  本类中符合给定参数列表的构造器的显式调用，也就是调用本类中的带参构造
		super()调用父类空参构造器， super(...)	明确调用父类中符合给定参数列表的构造方法，也就是调用父类中的带参构造
	特别注意：只能在构造方法中通过 this(...) super(...)   调用本类中或者父类中的构造方法，在成员方法中不能进行构造方法的调用
	调用成员方法
		this.成员方法 	调用本类的成员方法
		super.成员方法 	调用父类的成员方法
构造方法
	1、用于对对象的数据进行初始化
		A:方法名和类名相同
		B:没有返回值类型，连void都不能有
		C:没有返回值，但是可以有 return语句 return;
	如果我们没写构造方法，系统将提供一个默认的无参构造方法，如果给出了构造方法，系统将不再提供默认构造方法
	如果这个时候，我们要使用无参构造方法，就必须自己给出
	2、继承中构造方法的关系
		A：子类中所有的构造方法默认都会访问父类中空参构造方法
		实际上子类每一个构造方法的第一条语句默认都是 super();即使并没有显示的写出来 super()会调用父类空参构造方法,
		因为子类继承父类,可能会使用父类的数据,子类初始化之前，一定要先完成父类数据的初始化,
		(super()会调用父类空参构造方法完成父类数据初始化)
		B：但是子类显式的调用了父类带参构造，空参构造便不会被调用，也就是说子类构造器中不调用父类构造器，就会默认调用父类
		空参构造器，调用了带参构造器，执行的是这个调用的构造器，但是在子类中一定要有一个父类构造器被调用，以便父类数据的初始化
		C：如果父类中没有空参构造(比如父类中给出了带参构造，这时父类空参构造便不存在)，这时要显式的给出父类带参构造器的调用
		否则就会报错，但是无论怎么调用，父类一定要有一个构造器被调用
		例如：父类空参构造C()未定义，必须显式调用父类其他构造器
		这时会提示：Implicit super constructor C() is undefined. Must explicitly invoke another constructor
		D：super(...),this(...)在子类构造器中一定在第一条语句上，否则就会造成父类构造被重复调用
		
类的初始化过程
	1、没有继承关系的类的初始化过程
		先成员变量的初始化(静态成员初始化和静态代码块初始化)
		普通成员变量的初始化或构造代码块的执行(构造代码块和普通成员变量初始化先后和他们定义位置有关)
		再执行构造方法
	A：当用到某个类的时候，例如创建该类的类对象或者首次访问该类中的静态数据成员时(即使没有创建该类的类对象)
	就会对该类进行初始化，先静态初始化(静态成员变量以及静态代码块)，普通成员变量初始化，构造器的执行
	B：若再次创建该类的类对象，静态初始化就不会再次执行了，
	即静态初始化只在类首次加载时初始化一次，普通成员变量还会再次进行初始化，构造器再次被执行
	C：如果首次访问类的静态数据成员，只会初始化类的静态成员，普通成员变量不会被初始化，构造器不会被执行
	静态初始化动作只在必要时进行，静态初始化只在类首次加载时只初始化一次
	
	2、具有继承关系体系的类的初始化过程
		A:继承体系的所有静态成员初始化(包括静态成员变量,静态代码块,先父类,后子类)
		B:父类初始化(先普通成员的初始化，再构造方法的调用)
		C:子类初始化(普通成员的初始化，再构造方法的调用)
	子类继承父类的初始化过程是分层初始化,先进行父类初始化，然后进行子类初始化,
	并不是在子类中遇到有 super(...)的地方才开始父类的初始化过程

方法重写与方法重载
	方法重写：
		出现在继承体系中，子类继承父类，重写父类中的方法，子类和父类方法签名要一样(方法名、返回值类型、参数列表一样)
		方法重写的注意事项
		父类中私有方法不能被重写
		子类重写父类方法时，访问权限要更开放
		父类静态方法，子类也必须通过静态方法进行重写
	方法重载
		本类中出现的方法名一样的方法，这些方法区别于参数列表不一样,返回值不一样也可以，但是并不建议
多态
	可以将子类对象赋予父类引用，通过父类引用，可以访问子类从父类继承的方法，但不能访问子类中特有的方法
	通过父类引用访问在子类中隐藏的成员变量，访问的是父类中相应的成员变量
	父类中private方法属于父类的实现，不是父类接口的部分，因此子类中和父类同名的private方法不是对父类方法的重写
	父类中的静态方法、private方法，final方法，以及子类对父类成员的隐藏都不属于多态范围，只有普通方法的调用才属于多态
	
	对象调用方法时，确定调用的是哪个对象的方法(是父类中的方法或者是子类继承自父类的方法)，这个事件叫做绑定
	Java多态的实现技术是动态绑定，确定父类引用实际上是指向子类中的哪一个
	Java对象变量是多态的，能保存不止一种类型的对象，也就是说能保存父类对象，或者子类对象、
	动态绑定：根据对象的动态类型、运行时类型来决定，
	静态绑定：根据变量声明的类型来决定
	静态类型、动态类型两者有时候是一致的有时候不是一致的

	构造器中的多态行为
		1、在基类构造器中调用将要在子类中进行覆盖的基类方法，执行的是子类中的方法体
		因此在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的0，这样就能解决在父类构造中调用将要在子类中进行覆盖
		的基类方法，执行子类方法体时，尚未进行初始化的问题，但是产生的结果往往和预期不一致
		2、编写构造器应该用尽可能简单的方法使对象进入正常状态，应该尽量避免在构造器中调用非private、非final方法
		在构造器中唯一能够安全调用的是类中private方法或者final方法(其实两者都是final方法)，因为这些方法在子类中不能被覆盖
	接口是一种更为严格的抽象类，类实现了某个接口，可以转化为接口类型，接口只能用public 默认进行修饰
	接口可以继承多个接口，类可以实现多个接口，类要先继承后实现
	接口作为参数类型，传入的是相应接口的实现类对象，根据传入参数的的不同，就执行不同(具体实现类中)的代码
	
内部类
	成员内部类(可以看做是外部类的成员，定义在其所在外部类的成员位置)
		内部类与其外部类相互访问的特点
			内部类可以直接访问外部类成员(包括private权限的成员)，外部类不能直接访问内部类成员,外部类访问内部类成员
			要创建内部类对象;若内部类被static修饰，只能访问被static修饰的外部类成员
		其他类(不是内部类所在的外部类)访问一个类的内部类的成员
			外部类名.内部类名  对象名 = 外部类对象.内部类对象
			1）Outer.Inner oi = new Outer().new Inner();  (Outer是外部类，Inner是该外部类的内部类)
			要想访问 Inner必须先通过Outer，通过Outer对Inner进行访问控制，这里可以理解为内部类是外部类的一个成员
			在拥有外部类对象之前是不能拥有内部类对象的，因为内部类对象会暗暗连接到创建他的外部类对象上
			2）若内部类被 static 修饰的情况  (OuterDemo是外部类，InnerDemo是该外部类的内部类)
			OuterDemo.InnerDemo oiDemo = new OuterDemo.InnerDemo();不需要创建外部类对象
			若内部类被static修饰，访问外部类成员的时候，只能访问被static修饰的外部类成员
			3）内部类被 private 修饰的情况
			可以防止在其他类对一个类的内部类进行访问，除了该内部类所在的外部类，该内部类不允许在其他类进行访问，
			内部类可以为外部类服务，但是其他类又访问不到该内部类，因此private内部类可用于类的设计，
			这种特点可以完全阻止依赖于类型的代码，完全隐藏了实现的细节，因此就可以任意更改内部类中的代码
			而其他类中由于访问不到该内部类，就和该内部类没有耦合，而不受该内部类改变所带来的影响
			改动所带来的影响，为生成Java高效代码提供了可能，使类具有改变底层实现细节的能力
			4）典型的应用是外部类有一个方法 (innerInstance),该方法返回一个指向内部类的引用
				class OuterClass{
					public InnerClass innerInstance(){
						return new InnerClass();
					}
					public InnerClass{}
					public static void main(String[] args){
						OuterClass.InnerClass oi = new OuterClass().innerInstance();
					}
				}
			5）内部类与“迭代器”设计模式
			Iterable 接口下面有iterator()方法
			Iterator 接口下面有next()、hasNext()、remove()方法
			集合类实现了Iterable接口因此都要重写接口中的iterator()方法，方法体是返回了一个实现了Iterator接口的
			内部类对象(new Itr()),该内部类实现了Iterator接口，因此要重写里面的的next()、hasNext()、remove()方法
			具体容器类调用iterator()方法返回的是容器类的一个内部类对象，通过该对象对元素进行操作
			为什么可以实现对元素的操作，正是因为内部类的存在，容器中的内部类自动拥有对外部类的所有成员访问权
			这正是内部类特点的体现
			6）内部类得到外部类的引用(return Outer.this)，外部类得到内部类的引用(return new Inner())
				class Outer{
					public Outer(){
					}
					class Inner{
						public Inner(){
						}
						public Outer getOuter(){
							return Outer.this; //获得外部类的引用，这种方式不会创建对象
						}
					}
					public Inner getInner(){ //获得内部类引用的方法
						return new Inner();
					}
				}
	局部内部类(创建于局部位置)
		1）局部内部类可以直接访问外部类成员，访问与该局部内部类位于一个方法中的被final修饰的局部变量
		原因：方法中的局部变量随着方法的调用完毕而消失，但是局部类对象不会随着方法调用完毕在堆内存中立即消失
		局部类对象还在继续使用着局部变量，因此局部变量要用final修饰，这样在堆内存中访问的局部变量就会变成常量值而继续被局部类对象所使用
		2）在一个方法中创建局部内部类
		在一个方法中的局部域中创建局部内部类
		在局部域中创建的内部类，只能在方法中的局部域中使用内部类，不能超出局部域的作用范围来使用
		局部内部类之前不能加访问控制符，因为他不属于外部类的一部分
		class OuterClass{
			class InnerA{
				//成员内部类
			}
			public void methods(){
				class InnerB{
					//局部内部类 (直接访问外部类成员以及该内部类所在的方法中的被final修饰的局部变量)
				}
				if(true){
					class InnerC{
						//方法局部域中的局部内部类(直接访问外部类成员，与该内部类所在的方法中的被final修饰的局部变量)
					}
					class InnerC = new InnerC(); //只能在局部域中创建类对象
				}
			}
		}
	匿名类：是一个实现了某个接口或者继承了某个类的子类匿名对象
		如果在一个类的方法内部定义了一个匿名类，该匿名类可以访问外部类的所有成员，包裹该匿名类的方法内被final修饰的局部变量
		以及匿名类中的成员变量
		匿名类与正常继承相比有一定局限，匿名类可以扩展类，实现接口，但只能有其一，也就是继承和实现不能同时体现，且实现接口只能实现一个接口
Java为什么需要内部类？内部类的存在是更好的操作其所在的外部类
内部类继承自某个类或实现某个接口，内部类的代码操作创建他的外部类对象，可以认为内部类提供了进入外部类的窗口
无论外部类是否继承某个类实现某个接口，内部类可以继承某个类实现某个接口，使内部类具有接口的功能，来实现对外部类的支持
具体的容器类中创建一个Itr的内部类来实现对具体容器类(外部类)的操作，具体的容器类中一个方法iterator()返回指向该类中内部类的引用
在类中可以创建多个内部类，这些内部类实现不同的接口，从而具有不同的功能，对其所在的外部类进行不同的操作
比如可以在具体的集合类中创建多个内部类实现对集合元素的不同方式的迭代

修饰符
	权限修饰符：private，默认的，protected，public
	状态修饰符：static，final
	抽象修饰符：abstract
	类：
		权限修饰符：默认修饰符，public (private可以修饰内部类)
		public 在其他包中可以创建该类的类对象，如果没有为类指定访问控制符，则是默认修饰符，
		在同一个包中可以创建该类的类对象，在该类所在包的包外则不能创建该类的类对象
		状态修饰符：final (static 可以修饰内部类)
		抽象修饰符：abstract
	成员变量：
		权限修饰符：private，默认的，protected，public
		状态修饰符：static，final
	构造方法：
		权限修饰符：private，默认的，protected，public
	成员方法：
		权限修饰符：private，默认的，protected，public
		状态修饰符：static，final
		抽象修饰符：abstract
		
接口和实现
	类的接口是暴露给其他类来使用的，类的实现是隐藏封装与类的内部的实现细节
	覆盖，只有方法属于父类接口的一部分时才会发生，父类中private方法不属于父类接口的一部分，而是隐藏于父类中的程序代码，是父类的实现部分
访问权限
	private权限
		只能在同类中进行访问(同类中访问控制符是透明的各成员之间可以相互访问)
		一个类的private权限的成员，在该类外部不能直接访问
		类中所有private方法都默认指定为final，private方法在类外无法继承，也就无法进行覆盖，为private方法增加final，不会增加任何含义
		子类继承父类，子类中有和父类中同名的private方法，则子类中并不是对父类方法的重写，该private方法是子类中定义的方法
	默认权限
		包级访问权限，同一个包中，一个类A可以访问另一个类B的默认权限(或者大于默认权限)的成员
	protected权限(其实是给子类来用的)
		子类继承父类，在子类中，通过子类对象可以访问(子类继承自)父类的protected权限的成员，但是在子类中通过父类
		对象反而不能访问父类的 protected 权限的成员，无论子类和父类是否在同一个包中
		当你想让一个类中的某个方法或成员变量在包中都可见，而且其子类也能访问(子类有可能和父类不在同一个包中)
		但又不想让其他类进行访问该类时，就可以用protected修饰符,只有继承关系的类之间才可以访问protected权限的成员
		如果将父类成员访问权限设置为public则在父类所在的包外部，其他类都可以进行访问，但是设置为protected权限
		只有继承了父类的子类才能访问，protected权限提供了一种特殊的跨包访问权限，必须是继承父类的子类才能访问不同包
		中的父类成员，如果没有继承关系，不同包中不能进行访问
	public权限
		任何情况下都可以进行访问，也就是说一个类中的成员是public权限的，在另一个类中可以访问，无论这两个类是否在同一个包中
	访问控制符的作用：
		A、简化类的使用者对类的理解，将类的实现细节进行封装，仅暴露类的接口部分，仅向外对使用者提供服务
		使类的内部实现与对该类的使用分离，当更改类的内部实现方式时，对使用该类库的代码不会产生大的影响，
		使类具有改变底层实现细节的能力，也就是对类内部的改动，不会影响类外部对该类既定的使用(和其他类的关系)
		B、访问控制符在一定程度上平衡了类内部设计与外部对该类使用的关系
			就像手机，只提供相应的接口实现对手机的操作，但是对于手机内部的具体实现，用户是无法进行直接操作的(访问权限的控制)，
		但是对手机的操作系统进行升级，相当于改变了手机内部的实现细节，但是外部还是通过以前的接口进行对手机的操作，
		也就是手机和外部对其使用的既定关系并不会发生变化(升级了系统，通过外设对机器的操作方式这种既定关系不变)
	关于继承访问权限思考
		子类继承父类，子类继承自父类的成员要比父类成员有更大的访问权限，子类重写继承的方法时,不可以降低方法的访问权限，
		子类继承父类的访问修饰符要比父类的更大，也就是要更加开放，父类是protected修饰的，其子类只能是protected
		或者public，绝对不能是default(默认的访问范围)或者private，还要注意的是，继承当中子类抛出的异常必须
		是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少，子类访问权限要比父类的大
		假设一个父类A拥有的方法 public void setXXX(){} 可以被其他任意对象调用
		这个方法被子类B重写父类方便为void setXXX(){} 即默认的访问权限，只能被本包极其子类所访问
		假设其他包中的对象C调用方法为： 
		get(A a){
		a.setXXX();
		}  所有A类的类对象都可以传递给参数a,通过该参数调用setXXX()方法，而此时传入的对象为B类对象，假设为b，此时b将转型为a
		但是B中的setXXX()方法的访问权限是默认权限，不能再包外进行访问，就会出错
final关键字
	修饰类：类不能被继承，不需要对该类做出任何变动
	修饰方法：方法不能被重写
	修饰成员变量：该成员变量变成了常量,被final修饰的成员变量只能赋值一次(一旦赋值，便不能再次被赋值)
	要么在成员变量的位置赋值，要么在构造方法中进行赋值，或者在构造代码块中赋值
	(被final修饰的成员变量初始化时机是在构造方法完毕前)
	final域在声明处未进行初始化，可以再构造代码块，构造方法中进行初始化，也就是final域在使用之前必须确保初始化
	final 修饰基本类型，基本类型变成常量，基本类型的值不变
	final 修饰引用类型，引用恒定不变，引用初始化指向一个对象，就不能再改为指向其他对象，但是对象本身却可以被修改
	既是 static 又是 final 修饰的域，只占据一段不能改变的存储空间

抽象类的特点
	抽象类和抽象方法要用关键字abstract修饰
	抽象方法必须为public或者protected，因为如果为private，则不能被子类继承，子类便无法实现该方法
	缺省情况下默认为public
	成员变量：既可以是变量，也可以是常量
	构造方法：虽然抽象类不能实例化，但是他有构造方法，用于子类访问父类数据的初始化
	成员方法：既可以是抽象的(强制要求子类在之后进行实现),也可以是非抽象的(子类继承的事情，提高代码复用性);
			有抽象方法的类一定是抽象类，但是抽象类不一定有抽象方法，一个类继承了抽象类或者实现了某个接口，
			必须将抽象类或者接口中所有抽象方法实现(给出抽象方法的方法体,可以空实现，方法体只有{}花括号里面什么都没有)
			否则该类必须声明为抽象类;
		抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，
		因为你不能用它来做任何事情
接口的的特点
	接口的存在在于接口可以增加许多类都需要实现的功能，不同类可以实现相同的接口，一个类
	也可以实现不同的接口，接口只强调具体的功能，不关心功能的具体实现过程
	一个类实现了某个接口要给出接口方法的具体实现，也就是给接口中的所有方法添加方法体
	成员变量：属性成员是用 public static final 来修饰的，接口中属性成员可以通过接口名来访问，且只能进行一次赋值
	成员方法：是 public abstract 来修饰的，成员变量和成员方法的这些修饰符可以全部或者部分省略
	接口中没有构造方法
	但是可以通过子类构造访问父类构造方法，所有类都默认继承了Object类，当其没有父类的时候访问的是Object类的构造方法
	且Object类的构造方法是无参的 Object()
		class A implements Inter{
			//类A实现接口 Inter
			public A(){
				super(); //子类构造中通过super访问父类构造方法
			}
		} 
		等价于
		class A extends Object implements Inter{
			//类A实现接口 Inter
			public A(){
				super(); //子类构造中通过super访问父类构造方法
			}
		}
		
抽象类和接口的区别：
	A:成员区别
		抽象类：
			成员变量：可以变量，也可以常量
			构造方法：有
			成员方法：可以包含非抽象的方法
		接口：
			成员变量：只可以常量,是 public static final 来修饰的
			成员方法：只能是抽象的,是 public abstract 来修饰的
			
	B:关系区别
		类与类：
			继承关系,只能单继承,但可以多层继承
		类与接口：
			实现关系,可以单实现,也可以多实现
			class Demo implements it1, it2, it3{
				//it1, it2, it3都是接口
			}
			并且还可以在继承一个类的同时实现多个接口
			class Demo extends A implements it1, it2, it3{
				//it1, it2, it3都是接口
			}
		接口与接口：
			继承关系,可以单继承,也可以多继承
			interface inter extends it1, it2, it3{
				//it1, it2, it3都是接口
			}
	C:设计理念区别
		抽象类中定义的是该继承体系的共性功能,更多的是事物的“原型”，是对事物的抽象
		接口中定义的是该继承体系的扩展功能，是对行为的抽象

		1)接口与抽象类的一个本质区别是，抽象类只是一种含有抽象方法的类。也就是说，抽象类是对常规类的进一步“抽象”
		常规类是可以直接实例化的，因为它所定义的方法都有了明确的实现，也就是说相应类对象的行为已经能够完全确定下来
		而抽象类包含抽象方法，也就是说对象的一部分行为还没有完全确定下来。可以把抽象方法也理解成一种需求描述，
		因为抽象类存在着“待解决的需求”，所以它不能实例化，只能先派生出子类，解决了这个需求后(也就是实现了抽象方法)
		才能够实例化,比如说抽象类People中定义一个write抽象方法，因为写这个动作不同人可以选择不同的方式完成
		(比如有的人是左撇子，拿笔姿势各不相同)因为抽象类是一种类，到具体实现的时候重写这个write方法
		
		2)抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，
		但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。
		那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行这个特性也设计为类，
		因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将飞行设计为一个接口Fly，包含方法fly()，
		然后Airplane和Bird分别根据自己的需要实现Fly这个接口，也就是说如果想要具有“飞”这个功能，都可以实现Fly这个接口
		然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承
		Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而接口 实现则是 “有没有”的关系。
		如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞
		若需要具备飞行这个特点，则可以实现这个接口，不想具备飞行就不实现这个接口
		
		3)设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，
		它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了
		ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，
		不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。
		也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，
		如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动(对于接口当向其中添加一个新的方法，那么实现了这个
		接口的类都需要做相应地改变，而对于抽象类,我们向其中添加非抽象方法，不需要它的派生类做任何改动)

	下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，
	此时我们可以定义通过抽象类和接口来定义这个抽象概念：

	abstract class Door {
		public abstract void open();
		public abstract void close();
	}

	或者：

	interface Door {
		public abstract void open();
		public abstract void close();
	}

	但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：

	1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；

	2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，
	也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。

	从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，
	open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，
	包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。

	abstract class Door {  //Door抽象类，里面有两个抽象方法，属于门的固有属性
		public abstract void open();
		public abstract void close();
	}

	interface Alarm  { //Alarm接口，接口是一扇门可选择的功能，属于们功能的外延功能，可以根据情况进行选择

		public abstract void alarm();
	}

	class Adoor extends Door implements Alarm  //具体的们可以继承Door抽象类，实现Alarm接口
	{
		public void alarm() {
			System.out.println("Adoor alarm ...");
		}

		public void open() {
			System.out.println("Adoor open ...");
		}

		public void close() {
			System.out.println("Adoor close ...");
		}
	}
	class Bdoor extends Door  			//并没有实现Alarm接口
	{
		public void open() {
			System.out.println("Bdoor open ...");
		}

		public void close() {
			System.out.println("Bdoor close ...");
		}
	}
	public class TestDoor {
		public static void main(String[] args) {
			Adoor adoor = new Adoor();
			adoor.alarm();
			adoor.open();
			adoor.close();
			Bdoor bdoor = new Bdoor();
			bdoor.open();
			bdoor.close();		
		}
	}
