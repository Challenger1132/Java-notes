/*
内部类
	成员内部类(可以看做是外部类的成员，定义在其所在外部类的成员位置)
		内部类与其外部类相互访问的特点
			内部类可以直接访问外部类成员(包括private权限的成员)，外部类不能直接访问内部类成员,外部类访问内部类成员
			要创建内部类对象;若内部类被static修饰，只能访问被static修饰的外部类成员
		其他类(不是内部类所在的外部类)访问一个类的内部类的成员
			外部类名.内部类名  对象名 = 外部类对象.内部类对象
			1）Outer.Inner oi = new Outer().new Inner();  (Outer是外部类，Inner是该外部类的内部类)
			要想访问 Inner必须先通过Outer，通过Outer对Inner进行访问控制，这里可以理解为内部类是外部类的一个成员
			在拥有外部类对象之前是不能拥有内部类对象的，因为内部类对象会暗暗连接到创建他的外部类对象上
			2）若内部类被 static 修饰的情况  (OuterDemo是外部类，InnerDemo是该外部类的内部类)
			OuterDemo.InnerDemo oiDemo = new OuterDemo.InnerDemo();不需要创建外部类对象
			若内部类被static修饰，访问外部类成员的时候，只能访问被static修饰的外部类成员
			3）内部类被 private 修饰的情况
			可以防止在其他类对一个类的内部类进行访问，除了该内部类所在的外部类，该内部类不允许在其他类进行访问，
			内部类可以为外部类服务，但是其他类又访问不到该内部类，因此private内部类可用于类的设计，
			这种特点可以完全阻止依赖于类型的代码，完全隐藏了实现的细节，因此就可以任意更改内部类中的代码
			而其他类中由于访问不到该内部类，就和该内部类没有耦合，而不受该内部类改变所带来的影响
			改动所带来的影响，为生成Java高效代码提供了可能，使类具有改变底层实现细节的能力
			4）典型的应用是外部类有一个方法 (innerInstance),该方法返回一个指向内部类的引用
				class OuterClass{
					public InnerClass innerInstance(){
						return new InnerClass();
					}
					public InnerClass{}
					public static void main(String[] args){
						OuterClass.InnerClass oi = new OuterClass().innerInstance();
					}
				}
			5）内部类与“迭代器”设计模式
			Iterable 接口下面有iterator()方法
			Iterator 接口下面有next()、hasNext()、remove()方法
			集合类实现了Iterable接口因此都要重写接口中的iterator()方法，方法体是返回了一个实现了Iterator接口的
			内部类对象(new Itr()),该内部类实现了Iterator接口，因此要重写里面的的next()、hasNext()、remove()方法
			具体容器类调用iterator()方法返回的是容器类的一个内部类对象，通过该对象对元素进行操作
			为什么可以实现对元素的操作，正是因为内部类的存在，容器中的内部类自动拥有对外部类的所有成员访问权
			这正是内部类特点的体现
			6）内部类得到外部类的引用(return Outer.this)，外部类得到内部类的引用(return new Inner())
				class Outer{
					public Outer(){
					}
					class Inner{
						public Inner(){
						}
						public Outer getOuter(){
							return Outer.this; //获得外部类的引用，这种方式不会创建对象
						}
					}
					public Inner getInner(){ //获得内部类引用的方法
						return new Inner();
					}
				}
	局部内部类(创建于局部位置)
		1）局部内部类可以直接访问外部类成员，访问与该局部内部类位于一个方法中的被final修饰的局部变量
		原因：方法中的局部变量随着方法的调用完毕而消失，但是局部类对象不会随着方法调用完毕在堆内存中立即消失
		局部类对象还在继续使用着局部变量，因此局部变量要用final修饰，这样在堆内存中访问的局部变量就会变成常量值而继续被局部类对象所使用
		2）在一个方法中创建局部内部类
		在一个方法中的局部域中创建局部内部类
		在局部域中创建的内部类，只能在方法中的局部域中使用内部类，不能超出局部域的作用范围来使用
		局部内部类之前不能加访问控制符，因为他不属于外部类的一部分
		class OuterClass{
			class InnerA{
				//成员内部类
			}
			public void methods(){
				class InnerB{
					//局部内部类 (直接访问外部类成员以及该内部类所在的方法中的被final修饰的局部变量)
				}
				if(true){
					class InnerC{
						//方法局部域中的局部内部类(直接访问外部类成员，与该内部类所在的方法中的被final修饰的局部变量)
					}
					class InnerC = new InnerC(); //只能在局部域中创建类对象
				}
			}
		}
	匿名类：是一个实现了某个接口或者继承了某个类的子类匿名对象
		如果在一个类的方法内部定义了一个匿名类，该匿名类可以访问外部类的所有成员，包裹该匿名类的方法内被final修饰的局部变量
		以及匿名类中的成员变量
		匿名类与正常继承相比有一定局限，匿名类可以扩展类，实现接口，但只能有其一，也就是继承和实现不能同时体现，且实现接口只能实现一个接口
Java为什么需要内部类？内部类的存在是更好的操作其所在的外部类
内部类继承自某个类或实现某个接口，内部类的代码操作创建他的外部类对象，可以认为内部类提供了进入外部类的窗口
无论外部类是否继承某个类实现某个接口，内部类可以继承某个类实现某个接口，使内部类具有接口的功能，来实现对外部类的支持
具体的容器类中创建一个Itr的内部类来实现对具体容器类(外部类)的操作，具体的容器类中一个方法iterator()返回指向该类中内部类的引用
在类中可以创建多个内部类，这些内部类实现不同的接口，从而具有不同的功能，对其所在的外部类进行不同的操作
比如可以在具体的集合类中创建多个内部类实现对集合元素的不同方式的迭代

修饰符
	权限修饰符：private，默认的，protected，public
	状态修饰符：static，final
	抽象修饰符：abstract
	类：
		权限修饰符：默认修饰符，public (private可以修饰内部类)
		public 在其他包中可以创建该类的类对象，如果没有为类指定访问控制符，则是默认修饰符，
		在同一个包中可以创建该类的类对象，在该类所在包的包外则不能创建该类的类对象
		状态修饰符：final (static 可以修饰内部类)
		抽象修饰符：abstract
	成员变量：
		权限修饰符：private，默认的，protected，public
		状态修饰符：static，final
	构造方法：
		权限修饰符：private，默认的，protected，public
	成员方法：
		权限修饰符：private，默认的，protected，public
		状态修饰符：static，final
		抽象修饰符：abstract
		

接口和实现
	类的接口是暴露给其他类来使用的，类的实现是隐藏封装与类的内部的实现细节
	覆盖，只有方法属于父类接口的一部分时才会发生，父类中private方法不属于父类接口的一部分，而是隐藏于父类中的程序代码，是父类的实现部分
访问权限
	private权限
		只能在同类中进行访问(同类中访问控制符是透明的各成员之间可以相互访问)
		一个类的private权限的成员，在该类外部不能直接访问
		类中所有private方法都默认指定为final，private方法在类外无法继承，也就无法进行覆盖，为private方法增加final，不会增加任何含义
		子类继承父类，子类中有和父类中同名的private方法，则子类中并不是对父类方法的重写，该private方法是子类中定义的方法
	默认权限
		包级访问权限，同一个包中，一个类A可以访问另一个类B的默认权限(或者大于默认权限)的成员
	protected权限(其实是给子类来用的)
		子类继承父类，在子类中，通过子类对象可以访问(子类继承自)父类的protected权限的成员，但是在子类中通过父类
		对象反而不能访问父类的 protected 权限的成员，无论子类和父类是否在同一个包中
		当你想让一个类中的某个方法或成员变量在包中都可见，而且其子类也能访问(子类有可能和父类不在同一个包中)
		但又不想让其他类进行访问该类时，就可以用protected修饰符,只有继承关系的类之间才可以访问protected权限的成员
		如果将父类成员访问权限设置为public则在父类所在的包外部，其他类都可以进行访问，但是设置为protected权限
		只有继承了父类的子类才能访问，protected权限提供了一种特殊的跨包访问权限，必须是继承父类的子类才能访问不同包
		中的父类成员，如果没有继承关系，不同包中不能进行访问
	public权限
		任何情况下都可以进行访问，也就是说一个类中的成员是public权限的，在另一个类中可以访问，无论这两个类是否在同一个包中
	访问控制符的作用：
		A、简化类的使用者对类的理解，将类的实现细节进行封装，仅暴露类的接口部分，仅向外对使用者提供服务
		使类的内部实现与对该类的使用分离，当更改类的内部实现方式时，对使用该类库的代码不会产生大的影响，
		使类具有改变底层实现细节的能力，也就是对类内部的改动，不会影响类外部对该类既定的使用(和其他类的关系)
		B、访问控制符在一定程度上平衡了类内部设计与外部对该类使用的关系
			就像手机，只提供相应的接口实现对手机的操作，但是对于手机内部的具体实现，用户是无法进行直接操作的(访问权限的控制)，
		但是对手机的操作系统进行升级，相当于改变了手机内部的实现细节，但是外部还是通过以前的接口进行对手机的操作，
		也就是手机和外部对其使用的既定关系并不会发生变化(升级了系统，通过外设对机器的操作方式这种既定关系不变)
	关于继承访问权限思考
		子类继承父类，子类继承自父类的成员要比父类成员有更大的访问权限，子类重写继承的方法时,不可以降低方法的访问权限，
		子类继承父类的访问修饰符要比父类的更大，也就是要更加开放，父类是protected修饰的，其子类只能是protected
		或者public，绝对不能是default(默认的访问范围)或者private，还要注意的是，继承当中子类抛出的异常必须
		是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少，子类访问权限要比父类的大
		假设一个父类A拥有的方法 public void setXXX(){} 可以被其他任意对象调用
		这个方法被子类B重写父类方便为void setXXX(){} 即默认的访问权限，只能被本包极其子类所访问
		假设其他包中的对象C调用方法为： 
		get(A a){
		a.setXXX();
		}  所有A类的类对象都可以传递给参数a,通过该参数调用setXXX()方法，而此时传入的对象为B类对象，假设为b，此时b将转型为a
		但是B中的setXXX()方法的访问权限是默认权限，不能再包外进行访问，就会出错
final关键字
	修饰类：类不能被继承，不需要对该类做出任何变动
	修饰方法：方法不能被重写
	修饰成员变量：该成员变量变成了常量,被final修饰的成员变量只能赋值一次(一旦赋值，便不能再次被赋值)
	要么在成员变量的位置赋值，要么在构造方法中进行赋值，或者在构造代码块中赋值
	(被final修饰的成员变量初始化时机是在构造方法完毕前)
	final域在声明处未进行初始化，可以再构造代码块，构造方法中进行初始化，也就是final域在使用之前必须确保初始化
	final 修饰基本类型，基本类型变成常量，基本类型的值不变
	final 修饰引用类型，引用恒定不变，引用初始化指向一个对象，就不能再改为指向其他对象，但是对象本身却可以被修改
	既是 static 又是 final 修饰的域，只占据一段不能改变的存储空间

抽象类的特点
	抽象类和抽象方法要用关键字abstract修饰
	抽象方法必须为public或者protected，因为如果为private，则不能被子类继承，子类便无法实现该方法
	缺省情况下默认为public
	成员变量：既可以是变量，也可以是常量
	构造方法：虽然抽象类不能实例化，但是他有构造方法，用于子类访问父类数据的初始化
	成员方法：既可以是抽象的(强制要求子类在之后进行实现),也可以是非抽象的(子类继承的事情，提高代码复用性);
			有抽象方法的类一定是抽象类，但是抽象类不一定有抽象方法，一个类继承了抽象类或者实现了某个接口，
			必须将抽象类或者接口中所有抽象方法实现(给出抽象方法的方法体,可以空实现，方法体只有{}花括号里面什么都没有)
			否则该类必须声明为抽象类;
		抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，
		因为你不能用它来做任何事情
接口的的特点
	接口的存在在于接口可以增加许多类都需要实现的功能，不同类可以实现相同的接口，一个类
	也可以实现不同的接口，接口只强调具体的功能，不关心功能的具体实现过程
	一个类实现了某个接口要给出接口方法的具体实现，也就是给接口中的所有方法添加方法体
	成员变量：属性成员是用 public static final 来修饰的，接口中属性成员可以通过接口名来访问，且只能进行一次赋值
	成员方法：是 public abstract 来修饰的，成员变量和成员方法的这些修饰符可以全部或者部分省略
	接口中没有构造方法
	但是可以通过子类构造访问父类构造方法，所有类都默认继承了Object类，当其没有父类的时候访问的是Object类的构造方法
	且Object类的构造方法是无参的 Object()
		class A implements Inter{
			//类A实现接口 Inter
			public A(){
				super(); //子类构造中通过super访问父类构造方法
			}
		} 
		等价于
		class A extends Object implements Inter{
			//类A实现接口 Inter
			public A(){
				super(); //子类构造中通过super访问父类构造方法
			}
		}
		
抽象类和接口的区别：
	A:成员区别
		抽象类：
			成员变量：可以变量，也可以常量
			构造方法：有
			成员方法：可以包含非抽象的方法
		接口：
			成员变量：只可以常量,是 public static final 来修饰的
			成员方法：只能是抽象的,是 public abstract 来修饰的
			
	B:关系区别
		类与类：
			继承关系,只能单继承,但可以多层继承
		类与接口：
			实现关系,可以单实现,也可以多实现
			class Demo implements it1, it2, it3{
				//it1, it2, it3都是接口
			}
			并且还可以在继承一个类的同时实现多个接口
			class Demo extends A implements it1, it2, it3{
				//it1, it2, it3都是接口
			}
		接口与接口：
			继承关系,可以单继承,也可以多继承
			interface inter extends it1, it2, it3{
				//it1, it2, it3都是接口
			}
	C:设计理念区别
		抽象类中定义的是该继承体系的共性功能,更多的是事物的“原型”，是对事物的抽象
		接口中定义的是该继承体系的扩展功能，是对行为的抽象

		1)接口与抽象类的一个本质区别是，抽象类只是一种含有抽象方法的类。也就是说，抽象类是对常规类的进一步“抽象”
		常规类是可以直接实例化的，因为它所定义的方法都有了明确的实现，也就是说相应类对象的行为已经能够完全确定下来
		而抽象类包含抽象方法，也就是说对象的一部分行为还没有完全确定下来。可以把抽象方法也理解成一种需求描述，
		因为抽象类存在着“待解决的需求”，所以它不能实例化，只能先派生出子类，解决了这个需求后(也就是实现了抽象方法)
		才能够实例化,比如说抽象类People中定义一个write抽象方法，因为写这个动作不同人可以选择不同的方式完成
		(比如有的人是左撇子，拿笔姿势各不相同)因为抽象类是一种类，到具体实现的时候重写这个write方法
		
		2)抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，
		但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。
		那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行这个特性也设计为类，
		因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将飞行设计为一个接口Fly，包含方法fly()，
		然后Airplane和Bird分别根据自己的需要实现Fly这个接口，也就是说如果想要具有“飞”这个功能，都可以实现Fly这个接口
		然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承
		Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而接口 实现则是 “有没有”的关系。
		如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞
		若需要具备飞行这个特点，则可以实现这个接口，不想具备飞行就不实现这个接口
		
		3)设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，
		它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了
		ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，
		不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。
		也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，
		如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动(对于接口当向其中添加一个新的方法，那么实现了这个
		接口的类都需要做相应地改变，而对于抽象类,我们向其中添加非抽象方法，不需要它的派生类做任何改动)

	下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，
	此时我们可以定义通过抽象类和接口来定义这个抽象概念：

	abstract class Door {
		public abstract void open();
		public abstract void close();
	}

	或者：

	interface Door {
		public abstract void open();
		public abstract void close();
	}

	但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：

	1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；

	2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，
	也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。

	从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，
	open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，
	包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。

	abstract class Door {  //Door抽象类，里面有两个抽象方法，属于门的固有属性
		public abstract void open();
		public abstract void close();
	}

	interface Alarm  { //Alarm接口，接口是一扇门可选择的功能，属于们功能的外延功能，可以根据情况进行选择

		public abstract void alarm();
	}

	class Adoor extends Door implements Alarm  //具体的们可以继承Door抽象类，实现Alarm接口
	{
		public void alarm() {
			System.out.println("Adoor alarm ...");
		}

		public void open() {
			System.out.println("Adoor open ...");
		}

		public void close() {
			System.out.println("Adoor close ...");
		}
	}
	class Bdoor extends Door  			//并没有实现Alarm接口
	{
		public void open() {
			System.out.println("Bdoor open ...");
		}

		public void close() {
			System.out.println("Bdoor close ...");
		}
	}
	public class TestDoor {
		public static void main(String[] args) {
			Adoor adoor = new Adoor();
			adoor.alarm();
			adoor.open();
			adoor.close();
			Bdoor bdoor = new Bdoor();
			bdoor.open();
			bdoor.close();		
		}
	}