车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存
多个线程同时读写某一块内存区域

多线程：
多线程程序包含两条或两条以上并发运行的部分，程序中每个这样的部分都叫一个线程(thread)，每个线程都有独立的执行路径
进程(process)本质上是一个执行的程序。
基于进程(process-based) 的多任务处理的特点是允许你的计算机同时运行两个或更多的程序(听音乐的同时，浏览网页)
在基于线程(thread-based) 的多任务处理环境中，线程是最小的执行单位。
这意味着一个程序可以同时执行两个或者多个任务的功能。例如，一个文本编辑器可以在打印的同时格式化文本

进程是系统进行资源分配和调用的独立单位，每个进程有自己的独立空间和系统资源，多进程是提高CPU使用效率
单线程：程序有一条执行路径，多线程：程序有多条执行路径，
线程是程序的不同执行路径，每个进程有多个任务，每个任务可以看成一个线程，线程是使用CPU基本单位
程序的执行就是抢CPU的执行权，如果某个进程有多条执行路径，就会有更高的几率抢占到CPU
设置线程优先级，线程优先级较高的执行几率比优先级底的执行几率要高，但是要在尝试次数多的情况下才能看到(线程的执行具有随机性)

多线程出现的意义
多线程程序比多进程程序需要更少的管理费用。进程是重量级的任务，需要分配它们自己独立的地址空间
进程间通信是昂贵和受限的。进程间的转换也是很需要花费的。另一方面，线程是轻量级的选手。
它们共享相同的地址空间并且共同分享同一个进程。
线程间通信是便宜的，线程间的转换也是低成本的。当Java程序使用多进程任务处理环境时，多进程程序不受Java的控制，而多线程则受Java控制。
多线程帮助你写出CPU最大利用率的高效程序，因为空闲时间保持最低。这对Java运行的交互式的网络互连环境是至关重要的，因为空闲时间是公共的。
举个例子来说，网络的数据传输速率远低于计算机处理能力，本地文件系统资源的读写速度远低于CPU的处理能力，
当然，用户输入也比计算机慢很多。在传统的单线程环境中，你的程序必须等待每一个这样的任务完成以后才能执行
下一步，尽管CPU有很多空闲时间，多线程使你能够获得并充分利用这些空闲时间

JVM虚拟机运行时单线程还是多线程？
	多线程的，至少有main线程，还有GC线程
为什么要重写run()方法？
	类中并不是所有的代码都需要被线程执行，为了进行区分，Java提供了Thread类中的该方法包含被线程执行的代码
线程中run()方法和start()方法的区别？
	run()方法里封装的是线程执行的代码，调用start()方法，先启动线程，再由JVM调用run()方法
操作系统的设计，因此可以归结为三点
	A:以多进程形式，允许多个任务同时运行；
	B:以多线程形式，允许单个任务分成不同的部分运行；
	C:提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源

线程问题
	|--	线程的生命周期
			新建：创建线程对象
			就绪：该线程有执行资格，但是没有执行权
				阻塞：由于一些操作线程阻塞，没有执行资格，没有执行权(必须先获得执行资格之后才能获得执行权)
			执行：有执行资格，有执行权
			死亡：线程对象变成垃圾，准备被回收
			线程执行流程图

	|--	创建线程的第二种方式适合多个相同程序的代码去处理同一资源的情况，将线程同程序代码，数据有效的分离，较好的体现了面向对象的设计思想
		避免由于Java单继承带来的局限性
		线程安全问题的分析
			多线程安全问题出现的原因：
				有多线程环境
				延迟
				共享数据
				多条语句共同操作共享数据
				解决思想，将多条语句设置为同步代码
	|--	同步代码块
			假设有tha thb thc 三个线程，三个线程都能走到这里，在这里抢占CPU的执行权，假设tha抢到了执行权，就进到同步代码块里面
			执行到sleep()tha进行休眠，假设这是thb抢到了执行权，这是发现已经上锁，进不到同步代码块里面,tha睡眠时间到
			就会被唤醒，继续执行，知道走出同步代码块，接着三个线程继续抢占CPU的执行权
			同步代码块：synchronized(对象){
							.....  //同步代码块解决线程安全问题的关键在于创建的对象上面，这个对象相当于一把锁，注意多个线程必须是同一把锁
						}  这里可以设想多个人(多个线程)上厕所，只允许一人使用，也就是只允许一个线程操作同步代码块里面的资源
	|--	线程同步的特点
			1、前提是有多个线程  
			2、多个线使用的同一把锁(使用同一个锁对象)，不同情况下的锁对象是不一样的
			3、有多个线程，多个线程都会判断同步上的锁，这是很耗费资源的，因此保持同步，效率会比较低
			|--	同步代码块格式以及锁对象？
					是任意的类对象
				同步方法的格式以及锁对象？
					将关键字synchronized加到方法之前 public synchronized void f() {.....}，其锁对象是关键字 this
				静态对象的锁对象？
					类对象.class

开辟线程的两种方式及其区别
实现Runnable接口
	public interface Runnable 该接口下面只有一个方法
	Runnable接口应该由那些打算通过某一线程执行其实例的类来实现，类必须定义一个称为 run 的无参数方法
	实现该接口的线程对象可以继承于其他类，实现了创建任务与Thread类的分离，创建更加灵活
继承Thread类
	创建的线程对象继承了Thread类，是该类的子类对象，不能再继承其他类
接口是对行为的抽象，是对功能的扩展，类想要某种功能，就去实现相应的接口，重写接口中的方法
Runnable对象(实现Runnable接口创建的线程对象)可以继承于其他类，
继承Thread类创建的线程对象，也就是我们的任务必须是Thread类的子类对象，就无法再去继承其他类
Java只支持单继承，当一个类继承与Thread类后，就无法继承与其他类，实现Runnable接口创建的线程对象

如果需要线程对象的时候，可以创建线程类，也可以创建返回值为Runnable对象的方法
	private ExecutorService pool = Executors.newFixedpool(4);
	pool.execute(sendFile(f));
	execute()方法的参数需要传进来Runnable接口对象，可以创建线程类
	class MyThread implements Runnable{
		.....
		@Override
		public void run() {
			
		}
	}
	或者创建返回值为Runnable的对象
		public Runnable sendFile(File file){
			return new Runnable() {  //这其实是方法的返回值是一个匿名类对象，是类对象，
				....				//在该对象中可以有属性，方法等，按照类的书写方式进行写就好
				@Override
				public void run() {
				}
			};
		}
	调用方式为：
		pool.execute(new Thread(new MyThread(f)));
		pool.execute(new MyThread(f));
		pool.execute(sendFile(f));
	或者直接匿名类来实现
		pool.execute(new Runnable(){
			@Override
			public void run() {
			}
		});

为什么要用join()方法(很自然的思考实现方式，一个等待另一个)
	A：在很多情况下，主线程生成并起动了子线程，如果子线程里运行耗时很长，主线程往往在子线程之前而结束，
	但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，
	这个时候就要用到join()方法了，让主线程等待子线程执行完毕主线程再结束
	B：例如，th.join();是该语句所在的线程(当前线程)等待调用join()方法的th线程所设定的时间，而不管th线程是否执行完毕
	就等待那么长时间，若没给出时间参数，就是当前线程等待th线程执行完毕在执行
	C：重载的join()方法可以让开发者自定义等待周期。和sleep()方法一样join()方法依赖于操作系统的时间处理机制，
	你不能假定join()方法将会精确的等待你所定义的时长。如同sleep()方法，join()方法响应中断并在中断时抛出InterruptedException
	
sleep()和yield()的区别
	sleep
	使线程进入阻塞状态，时间可设定，睡眠结束进入就绪状态，sleep期间的线程不能被执行，可以允许较低优先级的线程执行
	yield
	使线程进入可执行状态，时间不可设定，执行yield后可能立即被执行，只将机会让给同等优先级的其他线程
	Thread.sleep(long millis)方法，使线程转到阻塞状态,millis参数设定睡眠的时间，
	以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态
	yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。
	使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，
	因为让步的线程还有可能被线程调度程序再次选中。yield()不是导致线程转到等待/睡眠/阻塞状态。
	在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果
	Thread.sleep()方法可以暂停当前线程一段时间，这是一种使处理器时间可以被其他线程或者运用程序使用的有效方式
	执行sleep()使线程进入不可运行状态，执行sleep()线程在指定的时间内肯定不会被执行，这段时间的长短是由程序设定的
	yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后又立即被执行
	yield()方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的
	实际上，yield()方法对应了如下操作：
	先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，
	继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程
	而sleep()方法允许较低优先级的线程获得运行机会，但yield()方法执行时，当前线程仍处在可运行状态，
	所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用
	sleep方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行
main方法其实也是一个线程,在java中所有的线程都是同时启动的，至于什么时候，哪个先执行，
完全看谁先得到CPU的资源。在java中，每次程序运行至少启动2个线程。一个是main线程，
一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际就是在操作系统中启动了一个进程